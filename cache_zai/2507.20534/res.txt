KKIMI K2: OPEN AGENTIC INTELLIGENCE
TECHNICAL REPORT OF KIMI K2
Kimi Team
ABSTRACT
We introduce Kimi K2, a Mixture-of-Experts (MoE) large language model with 32 billion activated parameters and 1 trillion total parameters. We propose the MuonClip optimizer, which improves upon Muon with a novel QK-clip technique to address training instability while enjoying the advanced token effciency of Muon. Based on MuonClip, K2 was pre-trained on 15.5 trillion tokens with zeroi loss spike. During post-training, K2 undergoes a multi-stage post-training process, highlighted by a large-scale agentic data synthesis pipeline and a joint reinforcement learning (RL) stage, where the model improves its capabilities through interactions with real and synthetic environments.
Kimi K2 achieves state-of-the-art performance among open-source non-thinking models, with strengths in agentic capabilities. Notably, K2 obtains 66.1 on Tau2-Bench, 76.5 on ACEBench(En), 65.8 on SWE-Bench Verifed, and 47.3 on SWE-Bench Multilingual — surpassing most openi and closed-sourced baselines in non-thinking settings. It also exhibits strong capabilities in coding,mathematics, and reasoning tasks, with a score of 53.7 on LiveCodeBench v6, 49.5 on AIME 2025,75.1 on GPQA-Diamond, and 27.1 on OJBench, all without extended thinking. These results position Kimi K2 as one of the most capable open-source large language models to date, particularly in software engineering and agentic tasks. We release our base and post-trained model checkpoints1 to facilitate future research and applications of agentic intelligence.
Figure 1: Kimi K2 main results.2

1Introduction
The development of Large Language Models (LLMs) is undergoing a profound paradigm shift towards Agentic Intelligence – the capabilities for models to autonomously perceive, plan, reason, and act within complex and dynamic environments. This transition marks a departure from static imitation learning towards models that actively learn through interactions, acquire new skills beyond their training distribution, and adapt behavior through experiences [63].It is believed that this approach allows an AI agent to go beyond the limitation of static human-generated data, and acquire superhuman capabilities through its own exploration and exploitation. Agentic intelligence is thus rapidly emerging as a defning capability for the next generation of foundation models, with wide-ranging implications acrossi tool use, software development, and real-world autonomy.
Achieving agentic intelligence introduces challenges in both pre-training and post-training. Pre-training must endow models with broad general-purpose priors under constraints of limited high-quality data, elevating token eff-i ciency—learning signal per token—as a critical scaling coeffcient. Post-training must transform those priors intoi actionable behaviors, yet agentic capabilities such as multi-step reasoning, long-term planning, and tool use are rare in natural data and costly to scale. Scalable synthesis of structured, high-quality agentic trajectories, combined with general reinforcement learning (RL) techniques that incorporate preferences and self-critique, are essential to bridge this gap.
In this work, we introduce Kimi K2, a 1.04 trillion-parameter Mixture-of-Experts (MoE) LLM with 32 billion activated parameters, purposefully designed to address the core challenges and push the boundaries of agentic capability. Our contributions span both the pre-training and post-training frontiers:
We present MuonClip, a novel optimizer that integrates the token-effcient Muon algorithm with a stability-i enhancing mechanism called QK-Clip. Using MuonClip, we successfully pre-trained Kimi K2 on 15.5 trillion tokens without a single loss spike.
We introduce a large-scale agentic data synthesis pipeline that systematically generates tool-use demonstrations via simulated and real-world environments. This system constructs diverse tools, agents, tasks, and trajectories to create high-fdelity, verifably correct agentic interactions at scale.ii
We design a general reinforcement learning framework that combines verifable rewards (RLVR) with a self-i critique rubric reward mechanism. The model learns not only from externally defned tasks but also from evaluatingi its own outputs, extending alignment from static into open-ended domains.
Kimi K2 demonstrates strong performance across a broad spectrum of agentic and frontier benchmarks. It achieves scores of 66.1 on Tau2-bench, 76.5 on ACEBench (en), 65.8 on SWE-bench Verifed, and 47.3 on SWE-benchi Multilingual, outperforming most open- and closed-weight baselines under non-thinking evaluation settings, closing the gap with Claude 4 Opus and Sonnet. In coding, mathematics, and broader STEM domains, Kimi K2 achieves 53.7 on LiveCodeBench v6, 27.1 on OJBench, 49.5 on AIME 2025, and 75.1 on GPQA-Diamond, further highlighting its capabilities in general tasks. On the LMSYS Arena leaderboard (July 17, 2025)3, Kimi K2 ranks as the top 1 open-source model and 5th overall based on over 3,000 user votes.
To spur further progress in Agentic Intelligence, we are open-sourcing our base and post-trained checkpoints, enabling the community to explore, refne, and deploy agentic intelligence at scale.i
2Pre-training
The base model of Kimi K2 is a trillion-parameter mixture-of-experts (MoE) transformer [72] model, pre-trained on 15.5 trillion high-quality tokens. Given the increasingly limited availability of high-quality human data, we posit that token effciency is emerging as a critical coeffcient in the scaling of large language models. To address this,ii we introduce a suite of pre-training techniques explicitly designed for maximizing token effciency. Specifcally, weii employ the token-effcient Muon optimizer [33, 46] and mitigate its training instabilities through the introduction ofi QK-Clip. Additionally, we incorporate synthetic data generation to further squeeze the intelligence out of available high-quality tokens. The model architecture follows an ultra-sparse MoE with multi-head latent attention (MLA) similar to DeepSeek-V3 [10] , derived from empirical scaling law analysis. The underlying infrastructure is built to optimize both training effciency and research effciency.ii

2.1MuonClip: Stable Training with Weight Clipping
We train Kimi K2 using the token-effcient Muon optimizer [33], incorporating weight decay and consistent updatei RMS scaling [46]. Experiments in our previous work Moonlight [46] show that, under the same compute budget and model size $.$ and therefore the same amount of training data — Muon substantially outperforms AdamW [36, 48],making it an effective choice for improving token effciency in large language model training.i
Training instability when scaling MuonDespite its effciency, scaling up Muon training reveals a challenge: trainingi instability due to exploding attention logits, an issue that occurs more frequently with Muon but less with AdamW in our experiments. Existing mitigation strategies are insuffcient. For instance, logit soft-cap [69] directly clips thei attention logits, but the dot products between queries and keys can still grow excessively before capping is applied. On the other hand, Query-Key Normalization (QK-Norm) [11, 81] is not applicable to multi-head latent attention (MLA),because its Key matrices are not fully materialized during inference.
Taming Muon with QK-ClipTo address this issue, we propose a novel weight-clipping mechanism $\mathit{QK\text{-}Clip}$  to explicitly constrain attention logits. QK-Clip works by rescaling the query and key projection weights post-update to bound the growth of attention logits.
Let the input representation of a transformer layer be X. For each attention head h, its query, key, and value projections are computed as
$$\textbf{Q}^{h}=\textbf{X}\textbf{W}_{q}^{h},\quad\textbf{K}^{h}=\textbf{X} \textbf{W}_{k}^{h},\quad\textbf{V}^{h}=\textbf{X}\textbf{W}_{v}^{h}.$$
where $\mathbf{W}_{q},\mathbf{W}_{k},\mathbf{W}_{v}$ are model parameters. The attention output is:
$$\mathbf{O}^{h}=\text{softmax}\left(\frac{1}{\sqrt{d}}\mathbf{Q}^{h}\mathbf{K}^{h\top}\right)\mathbf{V}^{h}.$$
We defne the max logit, a per-head scalar, as the maximum input to softmax in this batch Bi
$$S_{\max}^{h}=\frac{1}{\sqrt{d}}\max_{\mathbf{X}\in B}\max_{i,j}\mathbf{Q}_{i}^{h}\mathbf{K}_{j}^{h\top}$$
where $i,j$ are indices of different tokens in a training sample X.
The core idea of QK-Clip is to rescale $\mathbf{W}_{k},\mathbf{W}_{q}$ whenever $S^{h}_{\max}$ exceeds a target threshold τ. Importantly, this operation does not alter the forward/backward computation in the current step — we merely use the max logit as a guiding signal to determine the strength to control the weight growth.
A naïve implementation clips all heads at the same time:
$$\mathbf{W}_{q}^{h}\leftrightarrow\gamma^{\alpha}\mathbf{W}_{q}^{h}\qquad\mathbf{W}_{k}^{h}\leftrightarrow\gamma^{1-\alpha}\mathbf{W}_{k}^{h}$$
where $\gamma=\min(1,\tau/S_{\max})$  with $S_{\max}=\text{max}_{h} S_{\max}^{h},$  and $\alpha$  is a balancing parameter typically set to 0.5, applying equal scaling to queries and keys.
However, we observe that in practice, only a small subset of heads exhibit exploding logits. In order to minimize our intervention on model training, we determine a per-head scaling factor $\gamma_{h}=\min(1,\tau{/S_{\max}^{h}}),$  and opt to apply per-head QK-Clip. Such clipping is straightforward for regular multi-head attention (MHA). For MLA, we apply clipping only on unshared attention head components:
• $\mathbf{q}^{\boldsymbol{C}}$ and $\mathbf{k}^{\boldsymbol{C}}$ (head-specifc components): each scaled byi $\sqrt{\gamma_{h}}$
• $\mathbf{q}^{R}$ (head-specifc rotary): scaled by γh,i
· $\mathbf{k}^{\boldsymbol{R}}$ (shared rotary): left untouched to avoid effect across heads.
MuonClip: The New OptimizerWe integrate Muon with weight decay, consistent RMS matching, and QK-Clip into a single optimizer, which we refer to as MuonClip (see Algorithm 1).
We demonstrate the effectiveness of MuonClip from several scaling experiments. First, we train a mid-scale 9B activated and 53B total parameters Mixture-of-Experts (MoE) model using the vanilla Muon. As shown in Figure 2 (Left), we observe that the maximum attention logits quickly exceed a magnitude of 1000, showing that attention logits explosion is already evident in Muon training to this scale. Max logits at this level usually result in instability during training,including signifcant loss spikes and occasional divergence.i

Algorithm 1 MuonClip Optimizer
1: for each training step $t$  do
2:// 1. Muon optimizer step
3:for each weight $\mathbf{W}\in\mathbb{R}^{\tiny n \times\tiny m}$  do
4: $\mathbf{M}_{t}=\mu\mathbf{M}_{t-1}+\mathbf{G}_{t}$
$\mathbf{O}_{t}=$ Newton-Schulz $(\mathbf{M}_{t})\cdot\sqrt{\max(n,m)}\cdot0.2$
6: $\mathbf{W}_{t}=\mathbf{W}_{t-1}-\eta\big(\mathbf{O}_{t}+\lambda\mathbf{W}_{t-1}\big)$
7:end for
8: $//2$  QK-Clip
9:for each attention head $h$  in every attention layer of the model do
10:Obtain $S^{h}_{\max}$  already computed during forward
11:if $S^{h}_{\max}>\tau$ then
12: $\gamma\leftrightarrow\tau/S_{\text{m}}^{h}$ ax
13: $\mathbf{W}_{qc}^{n}\leftrightarrow\mathbf{W}_{qc}^{n}\cdot\sqrt{\gamma}$
14: $\mathbf{W}_{kc}^{h}\leftrightarrow\mathbf{W}_{kc}^{h}\cdot\sqrt{\gamma}$
15: $\mathbf{W}_{\mathit{qr}}^{\mathit{h}}\leftrightarrow\mathbf{W}_{\mathit{qr}}^{\mathit{h}}\cdot\gamma$
17:end for
Figure 2: Left: During a mid-scale training run, attention logits rapidly exceed 1000, which could lead to potential numerical instabilities and even training divergence. Right: Maximum logits for Kimi K2 with MuonClip and $\tau=100$ over the entire training run. The max logits rapidly increase to the capped value of 100, and only decay to a stable range after approximately $30\%$  of the training steps, demonstrating the effective regulation effect of QK-Clip.
Next, we demonstrate that QK-Clip does not degrade model performance and confrm that the MuonClip optimizeri preserves the optimization characteristics of Muon without adversely affecting the loss trajectory. A detailed discussion of the experiment designs and fndings is provided in the Appendix D.i
Finally, we train Kimi K2, a large-scale MoE model, using MuonClip with $\tau=100$  and monitor the maximum attention logits throughout the training run (Figure 2 (Right)). Initially, the logits are capped at 100 due to QK-Clip. Over the course of training, the maximum logits gradually decay to a typical operating range without requiring any adjustment toτ. Importantly, the training loss remains smooth and stable, with no observable spikes, as shown in Figure 3, validating that MuonClip provides robust and scalable control over attention dynamics in large-scale language model training.
2.2Pre-training Data: Improving Token Utility with Rephrasing
Token effciency in pre-training refers to how much performance improvement is achieved for each token consumedi during training. Increasing token utility—the effective learning signal each token contributes—enhances the per-token impact on model updates, thereby directly improving token effciency. This is particularly important when the supply ofi high-quality tokens is limited and must be maximally leveraged. A naive approach to increasing token utility is through repeated exposure to the same tokens, which can lead to overftting and reduced generalization.i

Figure 3: Per-step training loss curve of Kimi K2, without smoothing or sub-sampling. It shows no spikes throughout the entire training process. Note that we omit the very beginning of training for clarity.
A key advancement in the pre-training data of Kimi K2 over Kimi K1.5 is the introduction of a synthetic data generation strategy to increase token utility. Specifcally, a carefully designed rephrasing pipeline is employed to amplify the volumei of high-quality tokens without inducing signifcant overftting. In this report, we describe two domain-specializedii rephrasing techniques—targeted respectively at the Knowledge and Mathematics domains—that enable this controlled data augmentation.
Knowledge Data RephrasingPre-training on natural, knowledge-intensive text presents a trade-off: a single epoch is insuffcient for comprehensive knowledge absorption, while multi-epoch repetition yields diminishing returns andi increases the risk of overftting. To improve the token utility of high-quality knowledge tokens, we propose a synthetici rephrasing framework composed of the following key components:
Style- and perspective-diverse prompting: To enhance linguistic diversity while maintaining factual integrity, we apply a range of carefully engineered prompts. These prompts guide a large language model to generate faithful rephrasings of the original texts in varied styles and from different perspectives.
Chunk-wise autoregressive generation: To preserve global coherence and avoid information loss in long documents, we adopt a chunk-based autoregressive rewriting strategy. Texts are divided into segments, rephrased individually, and then stitched back together to form complete passages. This method mitigates implicit output length limitations that typically exist with LLMs. An overview of this pipeline is presented in Figure 4.
Fidelity verifcation: To ensure consistency between original and rewritten content, we perform fdelity checksii that compare the semantic alignment of each rephrased passage with its source. This serves as an initial quality control step prior to training.
We compare data rephrasing with multi-epoch repetition by testing their corresponding accuracy on SimpleQA. We experiment with an early checkpoint of K2 and evaluate three training strategies: (1) repeating the original dataset for 10 epochs, (2) rephrasing the data once and repeating it for 10 epochs, and (3) rephrasing the data 10 times with a single training pass. As shown in Table 1, the accuracy consistently improves across these strategies, demonstrating the effcacy of our rephrasing-based augmentation. We extended this method to other large-scale knowledge corpora andi observed similarly encouraging results, and each corpora is rephrased at most twice.
Table 1: SimpleQA Accuracy under three rephrasing-epoch confgurationsi


<html><body><table><thead><tr><td># Rephrasings</td><td># Epochs</td><td>SimpleQA Accuracy</td></tr></thead><tbody><tr><td>0 (raw wiki-text)</td><td>10</td><td>23.76</td></tr><tr><td>1</td><td>10</td><td>27.39</td></tr><tr><td>10</td><td>1</td><td>28.94</td></tr></tbody></table></body></html>


Figure 4: Auto-regressive chunk-wise rephrasing pipeline for long input excerpts. The input is split into smaller chunks with preserved context, rewritten sequentially, and then concatenated into a full rewritten passage.
Mathematics Data RephrasingTo enhance mathematical reasoning capabilities, we rewrite high-quality mathematical documents into a “learning-note” style, following the methodology introduced in SwallowMath [15]. In addition,we increased data diversity by translating high-quality mathematical materials from other languages into English.
Although initial experiments with rephrased subsets of our datasets show promising results, the use of synthetic data as a strategy for continued scaling remains an active area of investigation. Key challenges include generalizing the approach to diverse source domains without compromising factual accuracy, minimizing hallucinations and unintended toxicity, and ensuring scalability to large-scale datasets.
Pre-training Data OverallThe Kimi K2 pre-training corpus comprises 15.5 trillion tokens of curated, high-quality data spanning four primary domains: Web Text, Code, Mathematics, and Knowledge. Most data processing pipelines follow the methodologies outlined in Kimi K1.5 [35]. For each domain, we performed rigorous correctness and quality validation and designed targeted data experiments to ensure the curated dataset achieved both high diversity and effectiveness.
2.3Model Architecture
Kimi K2 is a 1.04 trillion-parameter Mixture-of-Experts (MoE) transformer model with 32 billion activated parameters.The architecture follows a similar design to DeepSeek-V3 [10] , employing Multi-head Latent Attention (MLA) [44] as the attention mechanism, with a model hidden dimension of 7168 and an MoE expert hidden dimension of 2048. Our scaling law analysis reveals that continued increases in sparsity yield substantial performance improvements, which motivated us to increase the number of experts to 384, compared to 256 in DeepSeek-V3. To reduce computational overhead during inference, we cut the number of attention heads to 64, as opposed to 128 in DeepSeek-V3. Table 2 presents a detailed comparison of architectural parameters between Kimi K2 and DeepSeek-V3.
Table 2: Architectural comparison between Kimi K2 and DeepSeek-V3


<html><body><table><tr><td></td><td>DeepSeek-V3</td><td>Kimi K2</td><td> $\Delta$ </td></tr><tr><td>#Layers</td><td>61</td><td>61</td><td>=</td></tr><tr><td>Total Parameters</td><td>671B</td><td>1.04T</td><td>￪54%</td></tr><tr><td>Activated Parameters</td><td>37B</td><td>32.6B</td><td> $\downarrow13\%$ </td></tr><tr><td>Experts (total)</td><td>256</td><td>384</td><td> $\uparrow50\%$ </td></tr><tr><td>Experts Active per Token</td><td>8</td><td>8</td><td>=</td></tr><tr><td>Shared Experts</td><td>1</td><td>1</td><td>=</td></tr><tr><td>Attention Heads</td><td>128</td><td>64</td><td> $\downarrow50\%$ </td></tr><tr><td>Number of Dense Layers</td><td>3</td><td>1</td><td> $\downarrow67\%$ </td></tr><tr><td>Expert Grouping</td><td>Yes</td><td>No</td><td>-</td></tr></table></body></html>


Sparsity Scaling LawWe develop a sparsity scaling law tailored for the Mixture-of-Experts (MoE) model family using Muon. Sparsity is defned as the ratio of the total number of experts to the number of activated experts. Throughi carefully controlled small-scale experiments, we observe that — under a fxed number of activated parameters (i.e.,i constant FLOPs) — increasing the total number of experts (i.e., increasing sparsity) consistently lowers both the training and validation loss, thereby enhancing overall model performance (Figure 5). Concretely, under the compute-optimal sparsity scaling law, achieving the same validation loss of 1.5, sparsity 48 reduces FLOPs by $1.69\times,1.39\times,$  and $1.15\times$ compared to sparsity levels 8, 16, and 32, respectively. Though increasing sparsity leads to better performance, this gain comes with increased infrastructure complexity. To balance model performance with cost, we adopt a sparsity of 48 for Kimi K2, activating 8 out of 384 experts per forward pass.
Figure 5: Sparsity Scaling Law. Increasing sparsity leads to improved model performance. We fxed the number ofi activated experts to 8 and the number of shared experts to 1, and varied the total number of experts, resulting in models with different sparsity levels.
Figure 6: Scaling curves for models with number of attention heads equals to number of layers and their counterparts with doubled attention heads. Doubling the number of attention heads leads to a reduction in validation loss of approximately $0.5\%$ to $1.2\%.$
Number of Attention HeadsDeepSeek-V3 [10] sets the number of attention heads to roughly twice the number of model layers to better utilize memory bandwidth and enhance computational effciency. However, as the context lengthi increases, doubling the number of attention heads leads to signifcant inference overhead, reducing effciency at longerii sequence lengths. This becomes a major limitation in agentic applications, where effcient long context processing isi essential. For example, with a sequence length of 128k, increasing the number of attention heads from 64 to 128, while keeping the total expert count fxed at 384, leads to ani $83\%$  increase in inference FLOPs. To evaluate the impact of this design, we conduct controlled experiments comparing confgurations where the number of attention heads equalsi the number of layers against those with double number of heads, under varying training FLOPs. Under iso-token training conditions, we observe that doubling the attention heads yields only modest improvements in validation loss(ranging from $0.5\%$ to $1.2\%$  across different compute budgets (Figure 6). Given that sparsity 48 already offers strong performance, the marginal gains from doubling attention heads do not justify the inference cost. Therefore we choose to 64 attention heads.
2.4Training Infrastructure
2.4.1Compute Cluster
Kimi K2 was trained on a cluster equipped with NVIDIA H800 GPUs. Each node in the H800 cluster contains 2 TB RAM and 8 GPUs connected by NVLink and NVSwitch within nodes. Across different nodes, $8 \times400$ Gbps RoCE interconnects are utilized to facilitate communications.
2.4.2Parallelism for Model Scaling
Training of large language models often progresses under dynamic resource availability. Instead of optimizing one parallelism strategy that’s only applicable under specifc amount of resources, we pursue a fexible strategy that allowsil Kimi K2 to be trained on any number of nodes that is a multiple of 32. Our strategy leverages a combination of 16-way

Figure 7: Computation, communication and offoading overlapped in different PP phases.l
Pipeline Parallelism (PP) with virtual stages [28, 53, 38, 57, 47, 21], 16-way Expert Parallelism (EP) [39], and ZeRO-1 Data Parallelism [60].
Under this setting, storing the model parameters in BF16 and their gradient accumulation buffer in FP32 requires approximately 6 TB of GPU memory, distributed over a model-parallel group of 256 GPUs. Placement of optimizer states depends on the training confgurations. When the total number of training nodes is large, the optimizer states arei distributed, reducing its per-device memory footprint to a negligible level. When the total number of training nodes is small (e.g., 32), we can offoad some optimizer states to CPU.l
This approach allows us to reuse an identical parallelism confguration for both small- and large-scale experiments,i while letting each GPU hold approximately 30 GB of GPU memory for all states. The rest of the GPU memory are used for activations, as described in Sec. 2.4.3. Such a consistent design is important for research effciency, as it simplifesii the system and substantially accelerates experimental iteration.
EP communication overlap with interleaved 1F1BBy increasing the number of warm-up micro-batches, we can overlap EP all-to-all communication with computation under the standard interleaved 1F1B schedule [21, 53]. In comparison, DualPipe [10] doubles the memory required for parameters and gradients, necessitating an increase in parallelism to compensate. Increasing PP introduces more bubbles, while increasing EP, as discussed below, incurs higher overhead. The additional costs are prohibitively high for training a large model with over 1 trillion parameters and thus we opted not to use DualPipe.
However, interleaved 1F1B splits the model into more stages, introducing non-trivial PP communication overhead. To mitigate this cost, we decouple the weight-gradient computation from each micro-batch’s backward pass and execute it in parallel with the corresponding PP communication. Consequently, all PP communications can be effectively overlapped except for the warm-up phase.
Smaller EP sizeTo ensure full computation-communication overlap during the 1F1B stage, the reduced attention computation time in K2 (which has 64 attention heads compared to 128 heads in DeepSeek-V3) necessitates minimizing the time of EP operations. This is achieved by adopting the smallest feasible EP parallelization strategy, specifcallyi $\mathrm{EP}=16.$  Utilizing a smaller EP group also relaxes expert-balance constraints, allowing for near-optimal speed to be achieved without further tuning.
2.4.3Activation Reduction
After reserving space for parameters, gradient buffers, and optimizer states, the remaining GPU memory on each device is insuffcient to hold the full MoE activations. To ensure the activation memory fts within the constraints, especiallyii for the initial pipeline stages that accumulate the largest activations during the 1F1B warm-up phase, the following techniques are employed.
Selective recomputationRecomputation is applied to inexpensive, high-footprint stages, including LayerNorm,SwiGLU, and MLA up-projections [10]. Additionally, MoE down-projections are recomputed during training to further reduce activation memory. While optional, this recomputation maintains adequate GPU memory, preventing crashes caused by expert imbalance in early training stages.
FP8 storage for insensitive activationsInputs of MoE up-projections and SwiGLU are compressed to FP8-E4M3 in $1 \times128$ tiles with FP32 scales. Small-scale experiments show no measurable loss increase. Due to potential risks of performance degradation that we observed during preliminary study, we do not apply FP8 in computation.

Activation CPU offoadAll remaining activations are offoaded to CPU RAM. A copy engine is responsible forll streaming the offoad and onload, overlapping with both computation and communication kernels. During the 1F1Bl phase, we offoad the forward activations of the previous micro-batch while prefetching the backward activations of thel next. The warm-up and cool-down phases are handled similarly and the overall pattern is shown in Figure 7. Although offoading may slightly affect EP traffc due to PCIe traffc congestion, our tests show that EP communication remainslii fully overlapped.
2.5Training recipe
We pre-trained the model with a 4,096-token context window using the MuonClip optimizer (Algorithm 1) and the WSD learning rate schedule [25], processing a total of 15.5T tokens. The frst 10T tokens were trained with a constanti learning rate of 2e-4 after a 500-step warm-up, followed by 5.5T tokens with a cosine decay from 2e-4 to 2e-5. Weight decay was set to 0.1 throughout, and the global batch size was held at 67M tokens. The overall training curve is shown in Figure 3.
Towards the end of pre-training, we conducted an annealing phase followed by a long-context activation stage. The batch size was kept constant at 67M tokens, while the learning rate was decayed from 2e-5 to 7e-6. In this phase, the model was trained on 400 billion tokens with a 4k sequence length, followed by an additional 60 billion tokens with a 32k sequence length. To extend the context window to 128k, we employed the YaRN method [55].
3Post-Training
3.1Supervised Fine-Tuning
We employ the Muon optimizer [33] in our post-training and recommend its use for fne-tuning with K2. This followsi from the conclusion of our previous work [46] that a Muon-pre-trained checkpoint produces the best performance with Muon fne-tuning.i
We construct a large-scale instruction-tuning dataset spanning diverse domains, guided by two core principles: maximizing prompt diversity and ensuring high response quality. To this end, we develop a suite of data generation pipelines tailored to different task domains, each utilizing a combination of human annotation, prompt engineering, and verifcation processes. We adopt K1.5 [35] and other in-house domain-specialized expert models to generate candidatei responses for various tasks, followed by LLMs or human-based judges to perform automated quality evaluation and fltering. For agentic data, we create a data synthesis pipeline to teach models tool-use capabilities through multi-step,i interactive reasoning.
3.1.1Large-Scale Agentic Data Synthesis for Tool Use Learning
A critical capability of modern LLM agents is their ability to autonomously use unfamiliar tools, interact with external environments, and iteratively refne their actions through reasoning, execution, and error correction. Agentic tool usei capability is essential for solving complex, multi-step tasks that require dynamic interaction with real-world systems.Recent benchmarks such as ACEBench [6] and $7$ -bench [85] have highlighted the importance of comprehensive tool-use evaluation, while frameworks like ToolLLM [58] and ACEBench [6] have demonstrated the potential of teaching models to use thousands of tools effectively.
However, training such capabilities at scale presents a signifcant challenge: while real-world environments providei rich and authentic interaction signals, they are often diffcult to construct at scale due to cost, complexity, privacyi and accessibility constraints. Recent work on synthetic data generation (AgentInstruct [51]; Self-Instruct [75];StableToolBench [20]; ZeroSearch [66]) has shown promising results in creating large-scale data without relying on real-world interactions. Building on these advances and inspired by ACEBench [6]’s comprehensive data synthesis framework, we developed a pipeline that simulates real-world tool-use scenarios at scale, enabling the generation of tens of thousands of diverse and high-quality training examples.
There are three stages in our data synthesis pipeline, depicted in Fig. 8.
Tool spec generation: we frst construct a large repository of tool specs from both real-world tools and LLM-i synthetic tools;
Agent and task generation: for each tool-set sampled from the tool repository, we generate an agent to use the toolset and some corresponding tasks;
Trajectory generation: for each agent and task, we generate trajectories where the agent fnishes the task byi invoking tools.

(a) Synthesizing tool specs, agents and tasks(b) Generating agent trajectories
(a) Synthesizing tool specs, agents and tasks
Figure 8: Data synthesis pipeline for tool use. (a) Tool specs are from both real-world tools and LLMs; agents and tasks are the generated from the tool repo. (b) Multi-agent pipeline to generate and flter trajectories with tool calling.i
(b) t-SNE visualization of synthetic tools, colored by pre-defnedi domain categories
i
(a) t-SNE visualization of real MCP tools, colored by their original source categories
Figure 9: t-SNE visualizations of tool embeddings. (a) Real-world MCP tools exhibit natural clustering based on their original source categories. (b) Synthetic tools are organized into pre-defned domain categories, providing systematici coverage of the tool space. Together, they ensure comprehensive representation across different tool functionalities.
Domain Evolution and Tool Generation.We construct a comprehensive tool repository through two complementary approaches. First, we directly fetch 3000+ real MCP (Model Context Protocol) tools from GitHub repositories,leveraging existing high-quality tool specs. Second, we systematically evolve [82] synthetic tools through a hierarchical domain generation process: we begin with key categories (e.g., fnancial trading, software applications, robot control),i then evolve multiple specifc application domains within each category. Specialized tools are then synthesized for eachi domain, with clear interfaces, descriptions, and operational semantics. This evolution process produces over 20,000 synthetic tools. Figure 9 visualizes the diversity of our tool collection through t-SNE embeddings, demonstrating that both MCP and synthetic tools cover complementary regions of the tool space.
Agent Diversifcation.We generate thousands of distinct agents by synthesizing various system prompts andi equipping them with different combinations of tools from our repository. This creates a diverse population of agents with varied capabilities, areas of expertise, and behavioral patterns, ensuring a broad coverage of potential use cases.
Rubric-Based Task Generation.For each agent confguration, we generate tasks that range from simple to complexi operations. Each task is paired with an explicit rubric that specifes success criteria, expected tool-use patterns, andi evaluation checkpoints. This rubric-based approach ensures a consistent and objective evaluation of agent performance.
Multi-turn Trajectory Generation.We simulate realistic tool-use scenarios through several components:
User Simulation: LLM-generated user personas with distinct communication styles and preferences engage in multi-turn dialogues with agents, creating naturalistic interaction patterns.

Tool Execution Environment: A sophisticated tool simulator (functionally equivalent to a world model) executes tool calls and provides realistic feedback. The simulator maintains and updates state after each tool execution,enabling complex multi-step interactions with persistent effects. It introduces controlled stochasticity to produce varied outcomes including successes, partial failures, and edge cases.
Quality Evaluation and Filtering.An LLM-based judge evaluates each trajectory against the task rubrics. Only trajectories that meet the success criteria are retained for training, ensuring high-quality data while allowing natural variation in task-completion strategies.
Hybrid Approach with Real Execution Environments.While simulation provides scalability, we acknowledge the inherent limitation of simulation fdelity. To address this, we complement our simulated environments with reali execution sandboxes for scenarios where authenticity is crucial, particularly in coding and software engineering tasks.These real sandboxes execute actual code, interact with genuine development environments, and provide ground-truth feedback through objective metrics such as test suite pass rates. This combination ensures that our models learn from both the diversity of simulated scenarios and the authenticity of real executions, signifcantly strengthening practicali agent capabilities.
By leveraging this hybrid pipeline that combines scalable simulation with targeted real-world execution, we generate diverse, high-quality tool-use demonstrations that balance coverage and authenticity. The scale and automation of our synthetic data generation, coupled with the grounding provided by real execution environments, effectively implements large-scale rejection sampling [26, 87] through our quality fltering process. This high-quality synthetic data, wheni used for supervised fne-tuning, has demonstrated signifcant improvements in the model’s tool-use capabilities across aii wide range of real-world applications.
3.2Reinforcement Learning
Reinforcement learning (RL) is believed to have better token effciency and generalization than SFT. Based on the worki of K1.5 [35], we continue to scale RL in both task diversity and training FLOPs in K2. To support this, we develop a Gym-like extensible framework that facilitates RL across a wide range of scenarios. We extend the framework with a large number of tasks with verifable rewards. For tasks that rely on subjective preferences, such as creative writing andi open-ended question answering, we introduce a self-critic reward in which the model performs pairwise comparisons to judge its own outputs. This approach allows tasks from various domains to all beneft from the RL paradigm.i
3.2.1Verifable Rewards Gymi
Math, STEM and Logical TasksFor math, stem and logical reasoning domains, our RL data preparation follows two key principles, diverse coverage and moderate diffculty.i
Diverse Coverage. For math and stem tasks, we collect high-quality QA pairs using a combination of expert annotations,internal QA extraction pipelines, and open datasets [41, 52]. During the collection process, we leverage a tagging system to deliberately increase coverage of under-covered domains. For logical tasks, our dataset comprises a variety of formats, including structured data tasks (e.g., multi-hop tabular reasoning, cross-table aggregation) and logic puzzles(e.g., the 24-game, Sudoku, riddles, cryptarithms, and Morse-code decoding).
Moderate Diffculty. The RL prompt-set should be neither too easy nor too hard, both of which may produce little signali and reduce learning effciency. We assess the diffculty of each problem using the SFT model’s pass@k accuracy andii select only problems with moderate diffculty.i
Complex Instruction FollowingEffective instruction following requires not only understanding explicit constraints but also navigating implicit requirements, handling edge cases, and maintaining consistency over extended dialogues.We address these challenges through a hybrid verifcation framework that combines automated verifcation withii adversarial detection, coupled with a scalable curriculum generation pipeline. Our approach employs a dual-path system to ensure both precision and robustness:
Hybrid Rule Verifcation. We implement two verifcation mechanisms: (1) deterministic evaluation via code interpretersii for instructions with verifable outputs (e.g., length, style constraints), and (2) LLM-as-judge evaluation for instructionsi requiring nuanced understanding of constraints. To address potential adversarial behaviors where models might claim instruction fulfllment without actual compliance, we incorporate an additional hack-check layer that specifcally detectsii such deceptive claims.
Multi-Source Instruction Generation. To construct our training data, we employ three distinct generation strategies to ensure comprehensive coverage: (1) expert-crafted complex conditional prompts and rubrics developed by our datateam (2) agentic instruction augmentation inspired by AutoIF [12], and (3) a fne-tuned model specialized for generatingi additional instructions that probe specifc failure modes or edge cases. This multipronged approach ensures both breadthi and depth in instruction coverage.
FaithfulnessFaithfulness is essential for an agentic model operating in scenarios such as multi-turn tool use, selfgenerated reasoning chains, and open-environment interactions. Inspired by the evaluation framework from FACTS Grounding [30], we train a sentence-level faithfulness judge model to perform automated verifcation. The judge isi effective in detecting sentences that make a factual claim without supporting evidence in context. It serves as a reward model to enhance overall faithfulness performance.
Coding $\&$  Software EngineeringTo enhance our capability in tackling competition-level programming problems,we gather problems and their judges from both open-source datasets [27, 83] and synthetic sources. To ensure the diversity of the synthetic data and the correctness of reward signals, we incorporate high-quality human-written unit tests retrieved from pre-training data.
For software engineering tasks, we collect a vast amount of pull requests and issues from GitHub to build software development environment that consists of user prompts/issues and executable unit tests. This environment was built on a robust sandbox infrastructure, powered by Kubernetes for scalability and security. It supports over 10,000 concurrent sandbox instances with stable performance, making it ideal for both competitive coding and software engineering tasks.
SafetyOur work to enhance the safety begins with a human-curated set of seed prompts, manually crafted to encompass prevalent risk categories such as violence, fraud, and discrimination.
To simulate sophisticated jailbreak attempts (e.g., role-playing, literary narratives, and academic discourse), we employ an automated prompt evolution pipeline with three key components:
Attack Model: Iteratively generates adversarial prompts designed to elicit unsafe responses from the target LLM.
Target Model: Produces responses to these prompts, simulating potential vulnerabilities.
Judge Model: Evaluates the interaction to determine if the adversarial prompt successfully bypasses safety mechanisms.
Each interaction is assessed using a task-specifc rubric, enabling the judge model to provide a binary success/failurei label.
3.2.2Beyond Verifcation: Self-Critique Rubric Rewardi
To extend model alignment beyond tasks with verifable reward, we introduce a framework for general reinforcementi learning from self-critic feedbacks. This approach is designed to align LLMs with nuanced human preferences,including helpfulness, creativity, depth of reasoning, factuality, and safety, by extending the capabilities learned from verifable scenarios to a broader range of subjective tasks. The framework operates using a Self-Critique Rubric Rewardi mechanism, where the model evaluates its own outputs to generate preference signals. To bootstrap K2 as a competent judge, we curated a mixture of open-source and in-house preference datasets and initialize its critic capability in the SFT stage.
Self-Critiqued Policy OptimizationIn the frst core process of the learning loop, the K2 actor generates responsesi for general prompts that cover a wide range of use cases. The K2 critic then ranks all results by performing pairwise evaluations against a combination of rubrics, which incorporates both core rubrics (Appendix. F.1), which represent the fundamental values of our AI assistant that Kimi cherish, prescriptive rubrics (Appendix. F.2) that aim to eliminate reward hacking, and human-annotated rubrics crafted by our data team for specifc instructional contexts. Althoughi certain rubrics can be designated as mandatory, K2 retains the fexibility to weigh them against its internal priors. Thisl capacity enables a dynamic and continuous alignment with its evolving on-policy behavior, ensuring that the model’s responses remain coherent with its core identity while adapting to specifc instructions.i
Closed-Loop Critic Refnement and AlignmentDuring RL training, the critic model is refned using verifableiii signals. On-policy rollouts generated from verifable-reward prompts are used to continuously update the critic, a cruciali step that distills objective performance signals from RLVR directly into its evaluation model. This transfer learning process grounds its more subjective judgments in verifable data, allowing the performance gains from verifableii tasks to enhance the critic’s judgment on complex tasks that lack explicit reward signals. This closed-loop process ensures that the critic continuously recalibrates its evaluation standards in lockstep with the policy’s evolution. Bygrounding subjective evaluation in verifable data, the framework enables robust and scalable alignment with complex,i non-verifable human objectives.i
Consequently, this holistic alignment yields comprehensive performance improvements across a wide spectrum of domains, including user intent understanding, creative writing, complex reasoning, and nuanced language comprehension.
3.2.3RL Algorithm
We adopt the policy optimization algorithm introduced in K1.5 [35] as the foundation for K2. For each problem x,we sample $K$  responses $\{y_{1},\ldots,y_{k}\}$  from the previous policy $\pi_{\text{old}},$  and optimize the model $\pi_{\theta}$  with respect to the following objective:
$$L_{\text{RL}}(\theta)=\mathbb{E}_{x\sim\mathcal{D}}\left[\frac{1}{K}\sum_{i=1}^{K}\left[\left(r(x,y_{i})-\bar{r}(x)-\tau\log\frac{\pi_{\theta}(y_{i}|x)}{\pi_{\text{old}}(y_{i}|x)}\right)^{2}\right]\right] ,$$
where $$  is the mean rewards of the sampled responses, $\tau>0$  is a regularization parameter that promotes stablke learning. As in SFT, we employ the Muon optimizer [33] to minimize this objective. As we scale RL training to encompass a broader range of tasks in K2, a primary challenge is achieving consistent performance improvements across all domains. To address this, we introduce several additions to the RL algorithm.
Budget ControlIt has been widely observed that RL often results in a substantial increase in the length of modelgenerated responses [35, 19]. While longer responses can enable the model to utilize additional test-time compute for improved performance on complex reasoning tasks, the benefts often do not justify its inference cost in non-reasoningi domains. To encourage the model to properly distribute inference budget, we enforce a per-sample maximum token budget throughout RL training, where the budget is determined based on the type of task. Responses that exceed this token budget are truncated and assigned a penalty, which incentivizes the model to generate solutions within the specifed limit. Empirically, this approach signifcantly enhances the model’s token effciency, encouraging concise yetiii effective solutions across all domains.
PTX LossTo prevent the potential forgetting of valuable, high-quality data during joint RL training, we curate a dataset comprising hand-selected, high-quality samples and integrate it into the RL objective through an auxiliary PTX loss [54]. This strategy not only leverages the advantages of high-quality data, but also mitigates the risk of overfttingi to the limited set of tasks explicitly present in the training regime. This augmentation substantially improves the model’s generalization across a broader range of domains.
Temperature DecayFor tasks such as creative writing and complex reasoning, we fnd that promoting explorationi via a high sampling temperature during the initial stages of training is crucial. A high temperature allow the model to generate diverse and innovative responses, thereby facilitating the discovery of effective strategies and reducing the risk of premature convergence to suboptimal solutions. However, retaining a high temperature in the later stages of training or during evaluation can be detrimental, as it introduces excessive randomness and compromises the reliability and consistency of the model’s outputs. To address this, we employ a temperature decay schedule, to shift from exploration to exploitation throughout the training. This strategy ensures that the model leverages exploration when it is most benefcial, while ultimately converge on stable and high-quality outputs.i
3.3RL Infrastructure
3.3.1Colocated Architecture
Similar to K1.5 [35], we adopt a hybrid colocated architecture for our synchronized RL training, where the training and inference engines live on the same workers. When one engine is actively working, the other engine releases or offoadsl its GPU resources to accommodate. In each iteration of RL training, a centralized controller frst calls the inferencei engine to generate new data for training. It then notifes the training engine to train on the new data, and send updatedi parameters to the inference engine for the next iteration.
Each engine is heavily optimized for throughput. In addition, as the model scales to the size of K2, the latency of engine switching and failure recovery becomes signifcant. We present our system design considerations in these aspects.i

Figure 10: Parameter update utilizing a checkpoint engine
3.3.2Effcient Engine Switchingi
During rollout, the parameters of the training engine are offoaded to DRAM. Bringing up the training engine isl therefore a simple step of H2D transmission. However, bringing up the inference engine is a bigger challenge, as it must obtain updated parameters from the training engine with a different sharding paradigm.
Given the scale of K2 and the vast number of devices involved, using a network fle system for resharding andi broadcasting parameters is impractical. The aggregate bandwidth required to keep overhead low reaches several petabytes per second. To address this challenge, we developed a distributed checkpoint engine co-located on training nodes to manage parameter states. To perform a parameter update, each checkpoint engine worker obtains a local copy of parameters from the training engine, then broadcasts the full parameter set across all checkpoint engine workers.Subsequently, the inference engine retrieves only the parameter shard it requires from the checkpoint engine. This process is illustrated in Figure 10. To enable this for a 1T model, updates are performed parameter-by-parameter in a pipelined manner, minimizing memory footprint (see Appendix G).
We opt to broadcast the full parameter set across the entire cluster, regardless of the specifc sharding schemes on eachi inference worker. While this transfers several times more data than a theoretically optimal approach, it offers a simpler system design that is less intrusive to the training and inference engines. We chose to trade off this minor overhead to fully decouple the training engine and the inference engine, signifcantly simplifying maintenance and testing.i
Notably, this approach outperforms the transfer-what-you-need method due to reduced synchronization overhead and higher network bandwidth utilization. Our system can complete a full parameter update for Kimi K2 with less than 30 seconds, a negligible duration for a typical RL training iteration.
3.3.3Effcient System Startupi
As large-scale training is prone to system failure, optimizing the startup time is crucial for models as large as Kimi K2.To start the training engine, we let each training worker selectively read part or none of the parameters from disk, and broadcast necessary parameters to its peers. The design goal is to ensure all workers collectively read the checkpoint only once, minimizing expensive disk IO.
As the inference engines are independent replicas, we would like to avoid introducing extra synchronization barriers between them. Therefore, we opt to reuse checkpoint engine for startup: we let checkpoint engine collectively read the checkpoint from disk, similar to how the training engine starts. Then it updates the state of the uninitialized inference engine, using the approach introduced in the previous section. By leveraging the dedicated checkpoint engine, the system also becomes robust to single-point failures, because an inference replica can restart without communicating with other replicas.
3.3.4Agentic Rollout
Our RL infrastructure supports the training of long-horizon, multi-turn agentic tasks. During rollout, these tasks present distinct challenges, such as complex environmental interactions and prolonged rollout durations. Here we introduce a few optimizations to alleviate these issues.
Due to the diversity of environments, certain interactions may be blocked on waiting for environment feedback (e.g., a virtual machine or a code interpreter), leaving the GPUs idle. We employ two strategies to maximize GPU utilization:(i) we deploy heavy environments as dedicated services that can scale up more easily; (ii) we employ a large number of concurrent rollouts to amortize the latency induced by certain expensive interactions.
Another challenge in agentic rollout is that individual rollout trajectories can be extremely long. To prevent long-tail trajectories from blocking the entire rollout process, we employ the partial rollout [35] technique. This strategy allows long-tail unfnished tasks to be paused, and resumed in the next RL iteration.i
To improve research effciency, we also design a unifed interface inspired by the OpenAI Gym framework [49] toii streamline the integration of new environments. We hope to scale our RL infrastructure to more diverse interactive environments in the future.
4Evaluations
This section begins with the post-training evaluation of Kimi-K2-Instruct, followed by a brief overview of the capabilities of Kimi-K2-Base. We conclude with a comprehensive safety evaluation.
4.1Post-training Evaluations
4.1.1Evaluation Settings
BenchmarksWe assess Kimi-K2-Instruct across different areas. For coding, we adopt LiveCodeBench v6 [31](questions from August 2024 to May 2025), OJBench [77], MultiPL-E [5], SWE-bench Verifed [32, 84], TerminalBench [71],i Multi-SWE-bench [86], SWE-Lancer [50], PaperBench [65], and Aider-Polyglot [16]. For tool use tasks, we evaluate performance on $\boldsymbol{\tau^{2}}$ -Bench [3] and AceBench [6], which emphasize multi-turn tool-calling capabilities. In reasoning,we include a wide range of mathematical, science and logical tasks: AIME 2024/2025, MATH-500, HMMT 2025,CNMO 2024, PolyMath-en, ZebraLogic [43], AutoLogi [91], GPQA-Diamond [61], SuperGPQA [13], and Humanity’s Last Exam (Text-Only) [56]. We benchmark the long-context capabilities on: MRCR4 for long-context retrieval, and DROP [14], FRAMES [37] and LongBench v2 [2] for long-context reasoning. For factuality, we evaluate FACTS Grounding [30], the Vectara Hallucination Leaderboard [73], and FaithJudge [68]. Finally, general capabilities are assessed using MMLU [23], MMLU-Redux [17], MMLU-Pro [76], IFEval [90], Multi-Challenge [64], SimpleQA [78],and LiveBench [80] (as of 2024-11-25).
BaselinesWe benchmark against both open-source and proprietary frontier models, ensuring every candidate is evaluated under its non-thinking confguration to eliminate additional gains from test-time compute. Open-sourcei baselines: DeepSeek-V3-0324 and Qwen3-235B-A22B, with the latter run in the vendor-recommended no-thinking regime. Proprietary baselines: Claude Sonnet 4, Claude Opus 4, GPT-4.1, and Gemini 2.5 Flash Preview (2025-05-20).Each invoked in its respective non-thinking mode via offcial APIs under unifed temperature and top-p settings.ii
Evaluation Confgurations All runs query models in their non-thinking mode. Output token length is capped ati 8192 tokens everywhere except SWE-bench Verifed (Agentless), which is raised to 16384. For benchmarks with highi per-question variance, we adopt repeated sampling $k$  times and average the results to obtain stable scores, denoted as Avg@k. For long-context tasks, we set the context window size to 128K tokens during evaluation, truncating any input that exceeds this limit to ft within the window. SWE-bench Verifed is evaluated in two modes: Agentless Codingii via Single Patch without Test (Acc) and Agentic Coding via bash/editor tools under both Single Attempt (Acc) and Multiple Attempts (Acc) using best-of-N selection with an internal verifer; SWE-bench Multilingual is tested only ini the single-attempt agentic setting. Some data points have been omitted due to prohibitively expensive evaluation costs.
4.1.2Evaluation Results
A comprehensive evaluation results of Kimi-K2-Instruct is shown in Table 3, with detailed explanation provided in the Appendix C. Below, we highlight key results across four core domains:
Agentic and Competitive CodingKimi-K2-Instruct demonstrates state-of-the-art open-source performance on real-world SWE tasks. It outperforms most baselines on SWE-bench Verifedi $(65.8\%,71.6\%$ with multiple attemps),SWE-bench Multilingual $(47.3\%]$ , and SWE-lancer (39.1%), signifcantly closing the gap with Claude 4 Opus andi Sonnet. On competitive coding benchmarks (e.g., LiveCodeBench v6 $53.7\%,$  OJBench $\bar{27.1\%})$ , it also leads among all models, highlighting its practical coding profciency across diffculty levels.ii

Table 3: Performance comparison of Kimi-K2-Instruct against leading open-source and proprietary models across diverse tasks. Bold denotes the global SOTA; underlined bold indicates the best open-source result. Data points marked with * are taken directly from the model’s technical report or blog.


<html><body><table><thead><tr><td></td><td colspan="3">Open Source</td><td colspan="3">Proprietary</td><td></td></tr><tr><td>Benchmark</td><td>Kimi-K2- Instruct</td><td>DeepSeek- V3-0324</td><td>Qwen3- 235B- A22B</td><td>Claude Sonnet 4</td><td>Claude Opus 4</td><td>GPT-4.1</td><td>Gemini 2.5 Flash</td></tr></thead><tbody><tr><td colspan="8">Coding Tasks</td></tr><tr><td>LiveCodeBench v6 (Pass@1)</td><td>53.7</td><td>46.9</td><td>37.0</td><td>48.5</td><td>47.4</td><td>44.7</td><td>44.7</td></tr><tr><td>OJBench (Pass@1)</td><td>27.1</td><td>24.0</td><td>11.3</td><td>15.3</td><td>19.6</td><td>19.5</td><td>19.5</td></tr><tr><td>MultiPL-E (Pass@1) SWE-bench Verifed</td><td>85.7</td><td>83.1</td><td>78.2</td><td>88.6</td><td>89.6</td><td>86.7</td><td>85.6</td></tr><tr><td>Agentless-Single-Patch (Pass@1)</td><td>51.8</td><td>36.6</td><td>39.4</td><td>50.2</td><td>53.0</td><td>40.8</td><td>32.6</td></tr><tr><td>SWE-bench Verifed Agentic-Single-Attempt (Pass@1)</td><td>65.8</td><td>38.8</td><td>34.4</td><td>72.7*</td><td> $72.5\text{*}$ </td><td>54.6</td><td>—</td></tr><tr><td>SWE-bench Verifed</td><td>71.6</td><td>—</td><td>—</td><td>80.2*</td><td> $79.4\text{*}$ </td><td>—</td><td>—</td></tr><tr><td>Agentic-Multi-Attempt (Pass@1) SWE-bench Multilingual (Pass@1)</td><td>47.3</td><td>25.8</td><td>20.9</td><td>51.0</td><td>—</td><td>31.5</td><td>—</td></tr><tr><td>Multi-SWE-bench (Pass@1)</td><td>18.3</td><td>8.0</td><td>9.0</td><td>29.2</td><td>—</td><td>11.7</td><td>14.0</td></tr><tr><td>SWE-Lancer (Pass@1)</td><td>39.1</td><td>30.5</td><td>24.1</td><td>40.8</td><td>—</td><td>23.0</td><td>38.5</td></tr><tr><td>Paper Bench Code-Dev (Acc.)</td><td>27.8</td><td>12.2</td><td>13.2</td><td>43.3</td><td></td><td>29.9</td><td>5.7</td></tr><tr><td>Terminal Bench In-House (Acc.)</td><td>30.0</td><td></td><td></td><td>35.5</td><td>43.2</td><td>8.3</td><td>—</td></tr><tr><td>Terminal Bench Terminus (Acc.)</td><td>25.0</td><td>16.3</td><td>6.6</td><td>—</td><td></td><td>30.3</td><td>16.8</td></tr><tr><td>Aider-Polyglot (Acc.)</td><td>60.0</td><td>55.1</td><td>61.8</td><td>56.4</td><td>70.7</td><td>52.4</td><td>44.0</td></tr><tr><td colspan="8">Tool Use Tasks</td></tr><tr><td>Tau2 retail (Avg@4)</td><td>70.6</td><td>69.1</td><td>57.0</td><td>75.0</td><td>81.8</td><td>74.8</td><td>64.3</td></tr><tr><td>Tau2 airline (Avg@4)</td><td>56.5</td><td>39.0</td><td>26.5</td><td>55.5</td><td>60.0</td><td>54.5</td><td>42.5</td></tr><tr><td>Tau2 telecom (Avg@4)</td><td>65.8</td><td>32.5</td><td>22.1</td><td>45.2</td><td>57.0</td><td>38.6</td><td>16.9</td></tr><tr><td>AceBench (Acc.)</td><td>76.5</td><td>72.7</td><td>70.5</td><td>76.2</td><td>75.6</td><td>80.1</td><td>74.5</td></tr><tr><td colspan="8">Math & STEM Tasks</td></tr><tr><td>AIME 2024 (Avg@64)</td><td>69.6</td><td>59.4*</td><td>40.1*</td><td>43.4</td><td>48.2</td><td>46.5</td><td>61.3</td></tr><tr><td>AIME 2025 (Avg@64)</td><td>49.5</td><td>46.7</td><td>24.7*</td><td>33.1*</td><td>33.9*</td><td>37.0</td><td>46.6</td></tr><tr><td>MATH-500 (Acc.)</td><td>97.4</td><td>94.0*</td><td>91.2*</td><td>94.0</td><td>94.4</td><td>92.4</td><td>95.4</td></tr><tr><td>HMMT 2025 (Avg@32)</td><td>38.8</td><td>27.5</td><td>11.9</td><td>15.9</td><td>15.9</td><td>19.4</td><td>34.7</td></tr><tr><td>CNMO 2024 (Avg@16)</td><td>74.3</td><td>74.7</td><td>48.6</td><td>60.4</td><td>57.6</td><td>56.6</td><td>75.0</td></tr><tr><td>PolyMath-en (Avg@4)</td><td>65.1</td><td>59.5</td><td>51.9</td><td>52.8</td><td>49.8</td><td>54.0</td><td>49.9</td></tr><tr><td>ZebraLogic (Acc.)</td><td>89.0</td><td>84.0</td><td>37.7*</td><td>79.7</td><td>59.3</td><td>58.5</td><td>57.9</td></tr><tr><td>AutoLogi (Acc.)</td><td>89.5</td><td>88.9</td><td>83.3*</td><td>89.8</td><td>86.1</td><td>88.2</td><td>84.1</td></tr><tr><td>GPQA-Diamond (Avg@8)</td><td>75.1</td><td>68.4*</td><td>62.9*</td><td>70.0*</td><td>74.9*</td><td>66.3</td><td>68.2</td></tr><tr><td>SuperGPQA (Acc.)</td><td>57.2 4.7</td><td>53.7 5.2</td><td>50.2 5.7</td><td>55.7 5.8</td><td>56.5 7.1</td><td>50.8 3.7</td><td>49.6 5.6</td></tr><tr><td colspan="8">Humanity’s Last Exam (Acc.) General Tasks</td></tr><tr><td>MMLU (EM)</td><td>89.5</td><td>89.4</td><td>87.0</td><td>91.5</td><td>92.9</td><td>90.4</td><td>90.1</td></tr><tr><td>MMLU-Redux (EM)</td><td>92.7</td><td>90.5</td><td>89.2*</td><td>93.6</td><td>94.2</td><td>92.4</td><td>90.6</td></tr><tr><td>MMLU-Pro (EM)</td><td>81.1</td><td>81.2*</td><td>77.3</td><td>83.7</td><td>86.6</td><td>81.8</td><td>79.4</td></tr><tr><td>IFEval (Prompt Strict)</td><td>89.8</td><td>81.1</td><td>83.2*</td><td>87.6</td><td>87.4</td><td>88.0</td><td>84.3</td></tr><tr><td>Multi-Challenge (Acc.)</td><td>54.1</td><td>31.4</td><td>34.0</td><td>46.8</td><td>49.0</td><td>36.4</td><td>39.5</td></tr><tr><td>SimpleQA (Correct)</td><td>31.0</td><td>27.7</td><td>13.2</td><td>15.9</td><td>22.8</td><td>42.3</td><td>23.3</td></tr><tr><td>Livebench (Pass@1) Arena Hard v2.0</td><td>76.4</td><td>72.4</td><td>67.6</td><td>74.8</td><td>74.6</td><td>69.8</td><td>67.8</td></tr><tr><td>Hard Prompt (Win rate)</td><td>54.5</td><td>39.9</td><td>39.9</td><td>51.6</td><td>59.7</td><td>51.7</td><td>48.7</td></tr><tr><td>Arena Hard v2.0</td><td>85.0</td><td>59.3</td><td>59.8</td><td>54.6</td><td>68.5</td><td>61.5</td><td>72.8</td></tr><tr><td>Creative Writing (Win rate) FACTS Grounding (Adjusted)</td><td>88.5</td><td></td><td></td><td></td><td></td><td>79.2</td><td>86.6</td></tr><tr><td>HHEM v2.1 (1-Hallu.)</td><td>98.9</td><td>68.3 88.9</td><td>68.5 94.5</td><td>83.6 94.5</td><td>—</td><td>96.7</td><td>97.8</td></tr><tr><td>FaithJudge (1-Hallu.)</td><td>92.6</td><td>83.4</td><td>75.7</td><td>83.0</td><td>—</td><td>91.0</td><td>93.2</td></tr><tr><td>LongBench v2 (Acc.)</td><td></td><td></td><td></td><td></td><td>—</td><td>54.3</td><td>55.5</td></tr><tr><td>FRAMES (Acc.)</td><td>49.1 77.1</td><td>51.1 79.2</td><td>—</td><td>52.5 76.3</td><td>—</td><td>87.4</td><td>72.9</td></tr><tr><td>MRCR (Acc.)</td><td>55.0</td><td>50.8</td><td>—</td><td>74.4</td><td>—</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td>—</td><td>66.9</td><td>81.7</td></tr><tr><td>DROP (Acc.)</td><td>93.5</td><td>91.2</td><td>84.3</td><td>92.0</td><td>—</td><td>79.1</td><td>81.7</td></tr></tbody></table></body></html>


Agentic Tool UseOn multi-turn tool-use benchmarks, Kimi-K2-Instruct sets a new standard. It achieves 66.1 Pass@1 on $\tau^{2}$ Bench and 76.5 on ACEBench, substantially outperforming all baselines. These results affrm its strength ini grounded, controlled, and agent-driven tool orchestration across domains.
General CapabilitiesKimi-K2-Instruct exhibits strong, balanced performance across general knowledge, math, instruction following, and long-context tasks. It surpasses open-source peers on SimpleQA $(31.0\%),$  MMLU $(89.5\%]$  and MMLU-Redux (92.7%), and leads all models on instruction benchmarks (IFEval: $89.8\%,$  Multi-Challenge: $54.1\%)$ In math and STEM, it achieves top-tier scores (AIME 2024: 69.6%, GPQA-Diamond: $75.1\%)$ , and remains competitive on long-context factuality and retrieval (DROP: 93.5%, MRCR: 55.0%). These results position Kimi-K2-Instruct as a well-rounded and capable generalist across both short- and long-context settings.
Open-Ended EvaluationOn the LMSYS Arena leaderboard (July 17, 2025), Kimi-K2-Instruct ranks as the top-1 open-source model and 5th overall based on over 3,000 user votes. This real-world preference signal—across diverse,blind prompts—underscores Kimi-K2’s strengths in generating high-quality responses on open-ended tasks.
4.2Pre-training Evaluations
4.2.1Evaluation Settings
BenchmarksWe evaluate Kimi-K2-Base across diverse capability areas. For general capabilities, we assess on MMLU [23], MMLU-Pro [76], MMLU-Redux [17], BBH [67], TriviaQA [34], SuperGPQA [13], SimpleQA [78], HellaSwag [88], AGIEval [89], GPQA-Diamond [61], ARC-Challenge [8], and WinoGrande [62]. For coding capabilities,we employ EvalPlus [45] (averaging HumanEval [7], MBPP [1], HumanEval+, and MBPP+), LiveCodeBench v6 [31],and CRUXEval [18]. For mathematical reasoning, we utilize GSM8K [9], GSM8K-Platinum [74], MATH [24], and CMATH [79]. For Chinese language capabilities, we evaluate on C-Eval [29], CMMLU [40], and CSimpleQA [22].
BaselinesWe benchmark against leading open-source foundation models: DeepSeek-V3-Base [10], Qwen2.5-72BBase [59] (Note that Qwen3-235B-A22B-Base is not open-sourced, and the largest open-sourced base model in the Qwen series is Qwen2.5-72B-Base), and Llama 4-Maverick [70] (Llama 4-Behemoth is also not open-sourced). All models are evaluated under identical confgurations to ensure fair comparison.i
Evaluation ConfgurationsWe employ perplexity-based evaluation for MMLU, MMLU-Redux, GPQA-Diamond,i HellaSwag, ARC-Challenge, C-Eval, and CMMLU. Generation-based evaluation is used for MMLU-Pro, SuperGPQA,TriviaQA, BBH, CSimpleQA, MATH, CMATH, GSM8K, GSM8K-Platinum, CRUXEval, LiveCodeBench, and EvalPlus. To mitigate the high variance inherent to GPQA-Diamond, we report the mean score across eight independent runs. All evaluations are conducted using our internal framework derived from LM-Harness-Evaluation [4], ensuring consistent settings across all models.
4.2.2Evaluation Results
Table 4 presents a comprehensive comparison of Kimi-K2-Base against leading open-source foundation models across diverse evaluation benchmarks. The results demonstrate that Kimi-K2-Base achieves state-of-the-art performance across the majority of evaluated tasks, establishing it as a leading foundation model in the open-source landscape.
General Language UnderstandingKimi-K2-Base achieves state-of-the-art performance on 10 out of 12 English language benchmarks. Notable results include MMLU (87.79%), MMLU-Pro (69.17%), MMLU-Redux (90.17%),SuperGPQA $(44.67\%)$ , and SimpleQA $(35.25\%$ , signifcantly outperforming all baselines.i
Coding CapabilitiesOn coding benchmarks, Kimi-K2-Base sets new standards with leading performance across all metrics. It achieves $74.00\%$  on CRUXEval-I-cot, $83.50\%$ on CRUXEval-O-cot, $26.29\%$ on LiveCodeBench v6, and $80.33\%$ on EvalPlus, demonstrating superior code generation and comprehension abilities, particularly in scenarios requiring step-by-step reasoning.
Mathematical ReasoningKimi-K2-Base exhibits exceptional mathematical capabilities, leading on three out of four benchmarks: MATH $(70.22\%)$  GSM8K (92.12%), and GSM8K-Platinum $(\hat{94}.21\%)$  It maintains competitive performance on CMATH $(90.26\%),$  narrowly behind DeepSeek-V3-Base $(90.53\%)$ . These results highlight the model’s robust mathematical problem-solving abilities across varying diffculty levels.i

Chinese Language UnderstandingThe model demonstrates superior multilingual capabilities, achieving state-of-theart results across all Chinese language benchmarks: C-Eval $(92.50\%)$ , CMMLU $(90.90\%$ , and CSimpleQA (77.57%).These results establish Kimi-K2-Base as a leading model for Chinese language understanding while maintaining strong performance across other languages.
Table 4: Performance comparison of Kimi-K2-Base against leading open-source models across diverse tasks.
Benchmark (Metric)#Shots Kimi-K2-Base DeepSeek-V3-Base Llama4-Maverick-Base Qwen2.5-72B-Base


<html><body><table><thead><tr><td># Total Params</td><td>Architecture # Activated Params</td><td>- - -</td><td>MoE 32B 1043B</td><td>MoE 37B 671B</td><td>MoE 17B 400B</td><td>Dense 72B 72B</td></tr></thead><tbody><tr><td rowspan="10"></td><td>MMLU</td><td>5-shots</td><td>87.79</td><td>87.10</td><td>84.87</td><td>86.08</td></tr><tr><td>MMLU-pro</td><td>5-shots</td><td>69.17</td><td>60.59</td><td>63.47</td><td>62.80</td></tr><tr><td>MMLU-redux</td><td>5-shots</td><td>90.17</td><td>89.53</td><td>88.18</td><td>87.77</td></tr><tr><td>SuperGPQA</td><td>5-shots</td><td>44.67</td><td>39.20</td><td>38.84</td><td>34.23</td></tr><tr><td>GPQA-Diamond(avg@8)</td><td> 5-shots</td><td>48.11</td><td>50.51</td><td>49.43</td><td>40.78</td></tr><tr><td>SimpleQA</td><td>5-shots</td><td>35.25</td><td>26.49</td><td>23.74</td><td>10.31</td></tr><tr><td>EnglishTriviaQA</td><td>5-shots</td><td>85.09</td><td>84.11</td><td>79.25</td><td>76.03</td></tr><tr><td>BBH</td><td>3-shots</td><td>88.71</td><td>88.37</td><td>87.10</td><td>84.09</td></tr><tr><td>HellaSwag</td><td>5-shots</td><td>94.60</td><td>89.44</td><td>86.02</td><td>95.27</td></tr><tr><td>AGIEval</td><td>-</td><td>84.23</td><td>81.57</td><td>67.55</td><td>76.87</td></tr><tr><td rowspan="3"></td><td>ARC-Challenge</td><td>0-shot</td><td>95.73</td><td>93.77</td><td>94.03</td><td>95.56</td></tr><tr><td>WinoGrande</td><td>5-shots</td><td>85.32</td><td>84.21</td><td>77.58</td><td>84.14</td></tr><tr><td>CRUXEval-I-cot</td><td>0-shots</td><td>74.00</td><td>62.75</td><td>67.13</td><td>61.12</td></tr><tr><td rowspan="4">Code</td><td>CRUXEval-O-cot LiveCodeBench(v6)</td><td>0-shots</td><td>83.50</td><td>75.25</td><td>75.88</td><td>66.13</td></tr><tr><td>EvalPlus</td><td>1-shots</td><td>26.29</td><td>24.57</td><td>25.14</td><td>22.29</td></tr><tr><td></td><td>-</td><td>80.33</td><td>65.61</td><td>65.48</td><td>66.04</td></tr><tr><td>MATH</td><td>4-shots</td><td>70.22</td><td>61.70</td><td>63.02</td><td>62.68</td></tr><tr><td rowspan="4">Math</td><td>GSM8k</td><td>8-shots</td><td>92.12</td><td>91.66</td><td>86.35</td><td>90.37</td></tr><tr><td>GSM8k-platinum</td><td>8-shots</td><td>94.21</td><td>93.38</td><td>88.83</td><td>92.47</td></tr><tr><td>CMATH</td><td>6-shots</td><td>90.26</td><td>90.53</td><td>88.07</td><td>86.98</td></tr><tr><td>C-Eval</td><td>5-shots</td><td>92.50</td><td>90.04</td><td>80.91</td><td>90.86</td></tr><tr><td rowspan="2">ChineseCMMLU</td><td></td><td>5-shots</td><td>90.90</td><td>88.84</td><td>81.24</td><td>90.55</td></tr><tr><td>CSimpleQA</td><td>5-shots</td><td>77.57</td><td>72.13</td><td>53.47</td><td>50.53</td></tr></tbody></table></body></html>

4.3Safety Evaluation
4.3.1Experiment Settings
We conducted red-teaming evaluations on Kimi K2 compare with other open-source LLMs. The evaluation covered a range of attack scenarios—including harmful content, privacy content, and security content, as well as different attack strategies such as prompt injection and iterative jailbreak.
We choose Promptfoo5 to generate adversarial prompts and analyze the responses. By this way, we can evaluate model in a scalable ways.
Model Selection We compare Kimi K2 with three other open-source LLMs: DeepSeek-V3, DeepSeek-R1, and Qwen3.Promptfoo Settings Table 5 lists plugins and strategies evaluated, with each plugin paired with all strategies to assess their performance.
Test Case Count Given the inherent non-determinism of large language model inference, single-pass outputs may exhibit variability. To account for this, we generated 3 attack prompts per plugin for each strategy.
Prompt Language Settings We pre-tested the language compatibility for each plugin-strategy combination. Some plugins support both English and Chinese, while others only support English. For combinations that support both, we generated 3 prompts in each language, resulting in 6 prompts per combination.

Table 5: Enabled Plugins and Strategies


<html><body><table><tr><td rowspan="5">Plugin</td><td>Harmful</td><td>Graphic Content, Harassment and Bullying, Hate Speech, Insults, Profanity, Radicalization, Self Harm, Sexual Content, ToxicChat</td></tr><tr><td>Criminal</td><td>Chemical&Biological Weapons, Child Exploitation, Copyright Violations, Cybercrime, Illegal Activities, Illegal Drugs, Indiscriminate Weapons, Intellectual Property Violation, Non-Violent Crime, Violent Crime, Sex Crimes</td></tr><tr><td>Misinformation</td><td> Competitor Endorsement, Unsupervised Contracts, Excessive Agency, Hallucination, Misin- formation and Disinformation, Specialized Advice, Unsafe Practices, Imitation, Overreliance, Political Opinions, Religious Sensitivity</td></tr><tr><td>Privacy</td><td>Privacy Violation, PII in API/Database, Direct PII Exposure, PII in Session Data, PII via Social Engineering</td></tr><tr><td>Security</td><td>ASCII Smuggling, CyberSecEval, Harmbench, Debug Access, Divergent Repetition, DoNotAn-</td></tr><tr><td colspan="3">swer, Malicious Code, Pliny, Prompt Extraction, Reasoning DoS, Tool Discovery Strategy Basic, Prompt Injection, Iterative Jailbreak, Crescendo</td></tr></table></body></html>

Manual Review We incorporated human review into the evaluation process. To minimize subjectivity problem, we conducted multiple rounds of review and assigned the same reviewer to evaluate all cases within a given test set to ensure consistency and reduce variability in judgment.
4.3.2Safety Evaluation Results
Table 6 presents the passing rates of different models under various plugin–strategy combinations.
Table 6: Safety Evaluation Results


<html><body><table><tr><td>Plugin Strategy</td><td></td><td colspan="4">Kimi-K2-Instruct DeepSeek-V3-0324 DeepSeek-R1 Qwen3-235B-A22B</td></tr><tr><td rowspan="5">Harmful</td><td>Basic</td><td>98.04</td><td>90.45</td><td>99.02</td><td>98.53</td></tr><tr><td>Base64</td><td>100</td><td>90.20</td><td>100</td><td>100</td></tr><tr><td>Prompt Injection</td><td>93.14</td><td>100</td><td>95.10</td><td>99.02</td></tr><tr><td>Iterative Jailbreak</td><td>92.16</td><td>66.67</td><td>72.55</td><td>74.51</td></tr><tr><td>Crescendo</td><td>64.71</td><td>64.71</td><td>80.39</td><td>86.27</td></tr><tr><td rowspan="5">Criminal</td><td>Basic</td><td>100</td><td>99.62</td><td>95.45</td><td>99.24</td></tr><tr><td>Base64</td><td>96.97</td><td>89.39</td><td>84.85</td><td>98.48</td></tr><tr><td>Prompt Injection</td><td>75.76</td><td>91.67</td><td>69.70</td><td>98.47</td></tr><tr><td>Iterative Jailbreak</td><td>57.57</td><td>21.21</td><td>25.76</td><td>53.03</td></tr><tr><td>Crescendo</td><td>56.06</td><td>31.81</td><td>42.42</td><td>59.09</td></tr><tr><td rowspan="5">Misinformation</td><td>Basic</td><td>97.28</td><td>92.57</td><td>92.46</td><td>94.84</td></tr><tr><td>Base64</td><td>98.48</td><td>90.48</td><td>96.83</td><td>93.65</td></tr><tr><td>Prompt Injection</td><td>98.39</td><td>86.51</td><td>93.65</td><td>93.65</td></tr><tr><td>Iterative Jailbreak</td><td>63.97</td><td>53.97</td><td>84.13</td><td>69.84</td></tr><tr><td>Crescendo</td><td>85.71</td><td>55.56</td><td>88.89</td><td>84.13</td></tr><tr><td rowspan="5">Privacy</td><td>Basic</td><td>100</td><td>100</td><td>100</td><td>100</td></tr><tr><td>Base64</td><td>100</td><td>100</td><td>100</td><td>100</td></tr><tr><td>Prompt Injection</td><td>88.33</td><td>98.33</td><td>100</td><td>91.67</td></tr><tr><td>Iterative Jailbreak</td><td>76.67</td><td>100</td><td>93.33</td><td>96.67</td></tr><tr><td>Crescendo</td><td>96.67</td><td>100</td><td>96.67</td><td>100</td></tr><tr><td rowspan="5">Security</td><td>Basic</td><td>77.84</td><td>75.57</td><td>70.46</td><td>90.09</td></tr><tr><td>Base64</td><td>82.93</td><td>82.93</td><td>63.41</td><td>95.12</td></tr><tr><td>Prompt Injection</td><td>87.80</td><td>97.56</td><td>65.85</td><td>84.13</td></tr><tr><td>Iterative Jailbreak</td><td>43.90</td><td>60.97</td><td>43.90</td><td>78.04</td></tr><tr><td>Crescendo</td><td>68.29</td><td>87.80</td><td>68.29</td><td>87.80</td></tr></table></body></html>

Without targeted optimization for specifc evaluation scenarios, the passing rate of some complex cases (e.g., Harm-i ful–Iterative Jailbreak) was relatively higher compared to other models.
Across different attack strategies, the models exhibited varying trends. Under the Base64 strategy, passing rates generally approached or reached $100\%,$  suggesting that encoding transformations had minimal impact on the models’basic robustness. In contrast, the Crescendo strategy led to a general drop in passing rates, indicating stronger adversarial effectiveness.
In addition, complex attack strategies do not always outperform basic prompts. Some originally adversarial prompts may lose their intended meaning after multiple rounds of transformation, rendering the resulting model outputs less meaningful.
Automated Red-teaming Limitations Due to the involvement of human review, the evaluation results inevitably contain a degree of subjectivity. Additionally, certain plugin types involve API misuse or external tool invocation, which are more suitable for evaluating agent models with tool-calling capabilities. In the context of base LLMs, such tests may have limited relevance.
5Limitations
In our internal tests, we have identifed some limitations in current Kimi K2 models. When dealing with hard reasoningi tasks or unclear tool defnition, the model may generate excessive tokens, sometimes leading to truncated outputs ori incomplete tool calls. Additionally, performance may decline on certain tasks if tool use is unnecessarily enabled. When building complete software projects, the success rate of one-shot prompting is not as good as using K2 under an agentic coding framework. We are working to address these issues in future releases and looking forward to more feedbacks.
6Conclusions
We introduced Kimi K2, a 1T-parameter open-weight MoE model built for agentic intelligence. Leveraging the tokeneffcient MuonClip optimizer and a 15.5T-token high-quality dataset, Kimi K2 achieves stable, scalable pre-training.i Post-training combines large-scale synthetic tool-use data with a unifed RL framework using both verifable rewardsii and self-critic feedbacks. Kimi K2 sets new state-of-the-art on agentic and reasoning benchmarks, establishing itself as the most capable open-weight LLM to date.
7Acknowledgments
We would like to acknowledge the valuable support provided by the OpenHands and Multi-SWE-bench teams in evaluating the SWE-bench Verifed and Multi-SWE-bench experimental results.i

References
[1]Jacob Austin et al. Program Synthesis with Large Language Models. 2021. arXiv: 2108.07732 [cs.PL]. URL:https://arxiv.org/abs/2108.07732.
[2]Yushi Bai et al. LongBench v2: Towards Deeper Understanding and Reasoning on Realistic Long-context Multitasks. 2025. arXiv: 2412.15204 [cs.CL]. URL: https://arxiv.org/abs/2412.15204.
[3]Victor Barres et al. $\boldsymbol{\tau^{2}}$ Bench: Evaluating Conversational Agents in a Dual-Control Environment. 2025. arXiv:2506.07982 [cs.AI]. URL: https://arxiv.org/abs/2506.07982.
[4]Stella Biderman et al. “Lessons from the trenches on reproducible evaluation of language models”. In: arXiv preprint arXiv:2405.14782 (2024).
[5]Federico Cassano et al. “MultiPL-E: A Scalable and Polyglot Approach to Benchmarking Neural Code Generation”. In: IEEE Transactions on Software Engineering 49.7 (2023), pp. 3675–3691. DOI: 10.1109/TSE.2023.3267446.
[6]Chen Chen et al. “ACEBench: Who Wins the Match Point in Tool Learning?” In: arXiv e-prints (2025), arXiv–2501.
[7]Mark Chen et al. “Evaluating Large Language Models Trained on Code”. In: (2021). arXiv: 2107.03374[cs.LG].
[8]Peter Clark et al. “Think you have solved question answering? try arc, the ai2 reasoning challenge”. In: arXiv preprint arXiv:1803.05457 (2018).
[9]Karl Cobbe et al. Training Verifers to Solve Math Word Problems. 2021. arXiv: 2110.14168 [cs.LG]. URL:i https://arxiv.org/abs/2110.14168.
[10]DeepSeek-AI. DeepSeek-V3 Technical Report. 2024. arXiv: 2412.19437 [cs.CL]. URL: https://arxiv.org/abs/2412.19437.
[11]Mostafa Dehghani et al. “Scaling vision transformers to 22 billion parameters”. In: International conference on machine learning. PMLR. 2023, pp. 7480–7512.
[12]Guanting Dong et al. Self-play with Execution Feedback: Improving Instruction-following Capabilities of Large Language Models. 2024. arXiv: 2406.13542 [cs.CL]. URL: https://arxiv.org/abs/2406.13542.
[13]Xinrun Du et al. “Supergpqa: Scaling llm evaluation across 285 graduate disciplines”. In: arXiv preprint arXiv:2502.14739 (2025).
[14]Dheeru Dua et al. “DROP: A Reading Comprehension Benchmark Requiring Discrete Reasoning Over Paragraphs”. In: CoRR abs/1903.00161 (2019). arXiv: 1903.00161. URL: http://arxiv.org/abs/1903.00161
[15]Kazuki Fujii et al. Rewriting Pre-Training Data Boosts LLM Performance in Math and Code. 2025. arXiv:2505.02881 [cs.LG]. URL: https://arxiv.org/abs/2505.02881.
l Gauthier. Aider LLM Leaderboards. https://aider.chat/docs/leaderboards/. 2025.
[17]Aryo Pradipta Gema et al. “Are we done with mmlu?” In: arXiv preprint arXiv:2406.04127 (2024).
[18]Alex Gu et al. “Cruxeval: A benchmark for code reasoning, understanding and execution”. In: arXiv preprint arXiv:2401.03065 (2024).
[19]Daya Guo et al. “Deepseek-r1: Incentivizing reasoning capability in llms via reinforcement learning”. In: arXiv preprint arXiv:2501.12948 (2025).
[20]Zhicheng Guo et al. “StableToolBench: Towards Stable Large-Scale Benchmarking on Tool Learning of Large Language Models”. In: arXiv preprint arXiv:2403.07714 (2025).
[21]Aaron Harlap et al. “Pipedream: Fast and effcient pipeline parallel dnn training”. In: arXiv preprinti arXiv:1806.03377 (2018).
[22]Y He et al. “Chinese simpleqa: A chinese factuality evaluation for large language models, 2024a”. In: URL https://arxiv. org/abs/2411.07140 ().
[23]Dan Hendrycks et al. “Measuring massive multitask language understanding”. In: arXiv preprint arXiv:2009.03300 (2020).
[24]Dan Hendrycks et al. Measuring Mathematical Problem Solving With the MATH Dataset. 2021. arXiv: 2103.03874 [cs.LG]. URL: https://arxiv.org/abs/2103.03874.
al. “Minicpm: Unveiling the potential of small language models with scalable training strategies t arXiv:2404.06395 (2024).
[26]Jiaxin Huang et al. “Large language models can self-improve”. In: arXiv preprint arXiv:2210.11610 (2022).
[27]Siming Huang et al. OpenCoder: The Open Cookbook for Top-Tier Code Large Language Models. 2025. arXiv:2411.04905 [cs.CL]. URL: https://arxiv.org/abs/2411.04905.

[28]Yanping Huang et al. “Gpipe: Effcient training of giant neural networks using pipeline parallelism”. In: Advancesi in neural information processing systems 32 (2019).
[29]Yuzhen Huang et al. C-Eval: A Multi-Level Multi-Discipline Chinese Evaluation Suite for Foundation Models.2023. arXiv: 2305.08322 [cs.CL]. URL: https://arxiv.org/abs/2305.08322.
[30]Alon Jacovi et al. The FACTS Grounding Leaderboard: Benchmarking LLMs’ Ability to Ground Responses to Long-Form Input. 2025. arXiv: 2501.03200 [cs.CL]. URL: https://arxiv.org/abs/2501.03200.
[31]Naman Jain et al. “Livecodebench: Holistic and contamination free evaluation of large language models for code”. In: arXiv preprint arXiv:2403.07974 (2024).
[32]Carlos E Jimenez et al. “SWE-bench: Can Language Models Resolve Real-world Github Issues?” In: The Twelfth International Conference on Learning Representations. 2024. URL: https://openreview.net/forum?id=VTF8yNQM66.
[33]Keller Jordan et al. Muon: An optimizer for hidden layers in neural networks. 2024. URL: https : / /kellerjordan.github.io/posts/muon/.
[34]Mandar Joshi et al. TriviaQA: A Large Scale Distantly Supervised Challenge Dataset for Reading Comprehension.2017. arXiv: 1705.03551 [cs.CL]. URL: https://arxiv.org/abs/1705.03551.
[35]Kimi Team. “Kimi k1. 5: Scaling reinforcement learning with llms”. In: arXiv preprint arXiv:2501.12599 (2025).
[36]Diederik P. Kingma and Jimmy Ba. “Adam: A Method for Stochastic Optimization”. In: 3rd International Conference on Learning Representations, ICLR 2015, San Diego, CA, USA, May 7-9, 2015, Conference Track Proceedings. Ed. by Yoshua Bengio and Yann LeCun. 2015. URL: http://arxiv.org/abs/1412.6980.
[37]Satyapriya Krishna et al. Fact, Fetch, and Reason: A Unifed Evaluation of Retrieval-Augmented Generation.i 2025. arXiv: 2409.12941 [cs.CL]. URL: https://arxiv.org/abs/2409.12941.
[38]Joel Lamy-Poirier. “Breadth-frst pipeline parallelism”. In: Proceedings of Machine Learning and Systems 5i(2023), pp. 48–67.
[39]Dmitry Lepikhin et al. “Gshard: Scaling giant models with conditional computation and automatic sharding”. In:arXiv preprint arXiv:2006.16668 (2020).
[40]Haonan Li et al. CMMLU: Measuring massive multitask language understanding in Chinese. 2024. arXiv:2306.09212 [cs.CL]. URL: https://arxiv.org/abs/2306.09212.
[41]Jia Li et al. “Numinamath: The largest public dataset in ai4maths with 860k pairs of competition math problems and solutions”. In: Hugging Face repository 13.9 (2024), p. 9.
[42]Tianle Li et al. “From Crowdsourced Data to High-Quality Benchmarks: Arena-Hard and BenchBuilder Pipeline”.In: arXiv preprint arXiv:2406.11939 (2024).
[43]Bill Yuchen Lin et al. ZebraLogic: On the Scaling Limits of LLMs for Logical Reasoning. 2025. arXiv: 2502.01100 [cs.AI]. URL: https://arxiv.org/abs/2502.01100.
[44]Aixin Liu et al. “Deepseek-v2: A strong, economical, and effcient mixture-of-experts language model”. In:i arXiv preprint arXiv:2405.04434 (2024).
[45]Jiawei Liu et al. “Is your code generated by chatgpt really correct? rigorous evaluation of large language models for code generation”. In: Advances in Neural Information Processing Systems 36 (2023), pp. 21558–21572.
an Liu et al. “Muon is scalable for LLM training”. In: arXiv preprint arXiv:2502.16982 (2025
[47]Ziming Liu et al. “Hanayo: Harnessing Wave-like Pipeline Parallelism for Enhanced Large Model Training Effciency”. In: Proceedings of the International Conference for High Performance Computing, Networking,i Storage and Analysis. SC ’23. ACM, Nov. 2023, pp. 1–13. DOI: 10.1145/3581784.3607073. URL: http://dx.doi.org/10.1145/3581784.3607073.
[48]Ilya Loshchilov and Frank Hutter. “Decoupled Weight Decay Regularization”. In: International Conference on Learning Representations. 2019. URL: https://openreview.net/forum?id=Bkg6RiCqY7.
[49]Jan Ludziejewski et al. OpenAI Gym. 2025. arXiv: 2502.05172 [cs.LG]. URL: https://arxiv.org/abs/2502.05172.
[50]Samuel Miserendino et al. “SWE-Lancer: Can Frontier LLMs Earn $1 Million from Real-World Freelance Software Engineering?” In: arXiv preprint arXiv:2502.12115 (2025).
[51]Arindam Mitra et al. “Agentinstruct: Toward generative teaching with agentic fows”. In: arXiv preprintl arXiv:2407.03502 (2024).
[52]Ivan Moshkov et al. “Aimo-2 winning solution: Building state-of-the-art mathematical reasoning models with openmathreasoning dataset”. In: arXiv preprint arXiv:2504.16891 (2025).
[53]Deepak Narayanan et al. “Effcient large-scale language model training on gpu clusters using megatron-lm”. In:i Proceedings of the international conference for high performance computing, networking, storage and analysis.2021, pp. 1–15.

[54]Long Ouyang et al. “Training language models to follow instructions with human feedback”. In: Advances in neural information processing systems 35 (2022), pp. 27730–27744.
[55]Bowen Peng et al. “Yarn: Effcient context window extension of large language models”. In: arXiv preprinti arXiv:2309.00071 (2023).
[56]Long Phan et al. Humanity’s Last Exam. 2025. arXiv: 2501.14249 [cs.LG]. URL: https://arxiv.org/abs/2501.14249.
ghui Qi et al. “Zero bubble pipeline parallelism”. In: arXiv preprint arXiv:2401.10241 (2023)
[58]Yujia Qin et al. “Toolllm: Facilitating large language models to master 16000+ real-world apis”. In: arXiv preprint arXiv:2307.16789 (2023).
[59]Qwen et al. Qwen2.5 Technical Report. 2025. arXiv: 2412.15115 [cs.CL]. URL: https://arxiv.org/abs/2412.15115.
[60]Samyam Rajbhandari et al. “Zero: Memory optimizations toward training trillion parameter models”. In: SC20:International Conference for High Performance Computing, Networking, Storage and Analysis. IEEE. 2020,pp. 1–16.
[61]David Rein et al. “Gpqa: A graduate-level google-proof q&a benchmark”. In: First Conference on Language Modeling. 2024.
[62]Keisuke Sakaguchi et al. “Winogrande: An adversarial winograd schema challenge at scale”. In: Communications of the ACM 64.9 (2021), pp. 99–106.
id Silver and Richard S Sutton. “Welcome to the era of experience”. In: Google AI 1 (2025).
[64]Ved Sirdeshmukh et al. MultiChallenge: $A$  Realistic Multi-Turn Conversation Evaluation Benchmark Challenging to Frontier LLMs. 2025. arXiv: 2501.17399 [cs.CL]. URL: https://arxiv.org/abs/2501.17399.
[65]Giulio Starace et al. “PaperBench: Evaluating AI’s Ability to Replicate AI Research”. In: arXiv preprint arXiv:2504.01848 (2025).
[66]Hao Sun et al. ZeroSearch: Incentivize the Search Capability of LLMs without Searching. 2025. arXiv: 2505.04588 [cs.CL]. URL: https://arxiv.org/abs/2505.04588.
[67]Mirac Suzgun et al. Challenging BIG-Bench Tasks and Whether Chain-of-Thought Can Solve Them. 2022. arXiv:2210.09261 [cs.CL]. URL: https://arxiv.org/abs/2210.09261.
[68]Manveer Singh Tamber et al. “Benchmarking LLM Faithfulness in RAG with Evolving Leaderboards”. In: arXiv preprint arXiv:2505.04847 (2025).
[69]Gemma Team et al. “Gemma 2: Improving open language models at a practical size”. In: arXiv preprint arXiv:2408.00118 (2024).
[70]LlaMA Team. The Llama 4 herd: The beginning of a new era of natively multimodal AI innovation — ai.meta.com.https://ai.meta.com/blog/llama-4-multimodal-intelligence/. [Accessed 15-07-2025].
[71]The Terminal-Bench Team. Terminal-Bench: A Benchmark for AI Agents in Terminal Environments. Apr. 2025.URL: https://github.com/laude-institute/terminal-bench.
[72]Ashish Vaswani et al. “Attention is All you Need”. In: Advances in Neural Information Processing Systems.Ed. by I. Guyon et al. Vol. 30. Curran Associates, Inc., 2017. URL: https://proceedings.neurips.cc/paper_files/paper/2017/file/3f5ee243547dee91fbd053c1c4a845aa-Paper.pdf.
[73]Vectara. Hallucination Evaluation Model (Revision 7437011). 2024. URL: https://huggingface.co/vectara/hallucination_evaluation_model
[74]Joshua Vendrow et al. “Do large language model benchmarks test reliability?” In: arXiv preprint arXiv:2502.03461 (2025).
[75]Yizhong Wang et al. “Self-instruct: Aligning language models with self-generated instructions”. In: arXiv preprint arXiv:2212.10560 (2022).
[76]Yubo Wang et al. MMLU-Pro: A More Robust and Challenging Multi-Task Language Understanding Benchmark.2024. arXiv: 2406.01574 [cs.CL]. URL: https://arxiv.org/abs/2406.01574.
[77]Zhexu Wang et al. OJBench: A Competition Level Code Benchmark For Large Language Models. 2025. arXiv:2506.16395 [cs.CL]. URL: https://arxiv.org/abs/2506.16395.
[78]Jason Wei et al. “Measuring short-form factuality in large language models”. In: arXiv preprint arXiv:2411.04368(2024).
[79]Tianwen Wei et al. CMATH: Can Your Language Model Pass Chinese Elementary School Math Test? 2023.arXiv: 2306.16636 [cs.CL]. URL: https://arxiv.org/abs/2306.16636.
[80]Colin White et al. “LiveBench: A Challenging, Contamination-Free LLM Benchmark”. In: The Thirteenth International Conference on Learning Representations. 2025.

[81]Mitchell Wortsman et al. “Small-scale proxies for large-scale transformer training instabilities, 2023”. In: URL https://arxiv. org/abs/2309.14322 ().
[82]Can Xu et al. WizardLM: Empowering large pre-trained language models to follow complex instructions. 2025.arXiv: 2304.12244 [cs.CL]. URL: https://arxiv.org/abs/2304.12244.
[83]Zhangchen Xu et al. KodCode: A Diverse, Challenging, and Verifable Synthetic Dataset for Coding. 2025. arXiv:i 2503.02951 [cs.LG]. URL: https://arxiv.org/abs/2503.02951.
[84]John Yang et al. SWE-smith: Scaling Data for Software Engineering Agents. 2025. arXiv: 2504.21798 [cs.SE].URL: https://arxiv.org/abs/2504.21798.
[85]Shunyu Yao et al. “tau-bench: A Benchmark for Tool-Agent-User Interaction in Real-World Domains”. In: arXiv preprint arXiv:2406.12045 (2024).
[86]Daoguang Zan et al. “Multi-swe-bench: A multilingual benchmark for issue resolving”. In: arXiv preprint arXiv:2504.02605 (2025).
[87]Eric Zelikman et al. “Star: Bootstrapping reasoning with reasoning”. In: Advances in Neural Information Processing Systems 35 (2022), pp. 15476–15488.
[88]Rowan Zellers et al. “Hellaswag: Can a machine really fnish your sentence?” In: arXiv preprint arXiv:1905.07830i(2019).
[89]Wanjun Zhong et al. “Agieval: A human-centric benchmark for evaluating foundation models”. In: arXiv preprint arXiv:2304.06364 (2023).
[90]Jeffrey Zhou et al. “Instruction-Following Evaluation for Large Language Models”. In: ArXiv abs/2311.07911(2023). URL: https://arxiv.org/abs/2311.07911.
[91]Qin Zhu et al. AutoLogi: Automated Generation of Logic Puzzles for Evaluating Reasoning Abilities of Large Language Models. 2025. arXiv: 2502.16906 [cs.CL]. URL: https://arxiv.org/abs/2502.16906.

Appendix
AContributions
The listing of authors is in alphabetical order based on their last names. Names marked with an asterisk (*) indicate people who are no longer part of our team.
Yifan Bai  
Yiping Bao  
Guanduo Chen  
Jiahao Chen  
Ningxin Chen  
Ruijue Chen  
Yanru Chen  
Yuankun Chen  
Yutian Chen  
Zhuofu Chen*  
Jialei Cui  
Hao Ding  
Mengnan Dong  
Ang’ang Du  
Chenzhuang Du  
Dikang Du  
Yulun Du  
Yu Fan  
Yichen Feng  
Kelin Fu  
Bofei Gao  
Hongcheng Gao  
Peizhong Gao  
Tong Gao  
Xinran Gu  
Longyu Guan  
Haiqing Guo*  
Jianhang Guo  
Hao Hu  
Xiaoru Hao  
Tianhong He  
Weiran He  
Wenyang He  
Chao Hong  
Yangyang Hu  
Zhenxing Hu  
Weixiao Huang  
Zhiqi Huang  
Zihao Huang  
Tao Jiang  
Zhejun Jiang  
Xinyi Jin  
Yongsheng Kang*
Guokun Lai  
Cheng Li  
Fang Li  
Haoyang Li  
Ming Li  
Wentao Li  
Yanhao Li  
Yiwei Li  
Zhaowei Li  
Zheming Li  
Hongzhan Lin*  
Xiaohan Lin  
Zongyu Lin  
Chengyin Liu  
Chenyu Liu  
Hongzhang Liu  
Jingyuan Liu*  
Junqi Liu  
Liang Liu  
Shaowei Liu  
T.Y. Liu  
Tianwei Liu  
Weizhou Liu  
Yangyang Liu  
Yibo Liu  
Yiping Liu  
Yue Liu  
Zhengying Liu  
Enzhe Lu  
Lijun Lu  
Shengling Ma  
Xinyu Ma  
Yingwei Ma  
Shaoguang Mao  
Jie Mei  
Xin Men  
Yibo Miao  
Siyuan Pan  
Yebo Peng  
Ruoyu Qin  
Bowen Qu  
Zeyu Shang  
Lidong Shi
Shengyuan Shi  
Feifan Song  
Jianlin Su  
Zhengyuan Su  
Xinjie Sun*  
Flood Sung  
Heyi Tang  
Jiawen Tao  
Qifeng Teng  
Chensi Wang  
Dinglu Wang  
Feng Wang  
Haiming Wang  
Jianzhou Wang*  
Jiaxing Wang  
Jinhong Wang  
Shengjie Wang  
Shuyi Wang  
Yao Wang  
Yejie Wang  
Yiqin Wang  
Yuxin Wang  
Yuzhi Wang  
Zhaoji Wang  
Zhengtao Wang  
Zhexu Wang  
Chu Wei  
Qianqian Wei  
Wenhao Wu  
Xingzhe Wu  
Yuxin Wu  
Chenjun Xiao  
Xiaotong Xie  
Weimin Xiong*  
Boyu Xu  
Jing Xu*  
Jinjing Xu  
L.H. Xu  
Lin Xu  
Suting Xu  
Weixin Xu  
Xinran Xu  
Yangchuan Xu
Ziyao Xu  
Junjie Yan  
Yuzi Yan  
Xiaofei Yang  
Ying Yang  
Zhen Yang  
Zhilin Yang  
Zonghan Yang  
Haotian Yao  
Xingcheng Yao  
Wenjie Ye  
Zhuorui Ye  
Bohong Yin  
Longhui Yu  
Enming Yuan  
Hongbang Yuan*  
Mengjie Yuan  
Haobing Zhan  
Dehao Zhang  
Hao Zhang  
Wanlu Zhang  
Xiaobin Zhang  
Yangkun Zhang  
Yizhi Zhang  
Yongting Zhang  
Yu Zhang  
Yutao Zhang  
Yutong Zhang  
Zheng Zhang  
Haotian Zhao  
Yikai Zhao  
Huabin Zheng  
Shaojie Zheng  
Jianren Zhou  
Xinyu Zhou  
Zaida Zhou  
Zhen Zhu  
Weiyu Zhuang  
Xinxing Zu  
Kimi K2

BToken Template of Tool Calling
There are three components in the token structure for tool-calling:
Tool declaration message: defnes the list of available tools and the schema of the argumenti
Tool invoking section in assistant message: encodes the model’s request to invoke tools;
Tool result message: encapsulates the invoked tool’s execution result.
The raw tokens of the tool declaration message are formatted as follows:
The blue highlighted marks represent special tokens, and the green part, quoted by brackets, is the tool declaration content. We use TypeScript to express the tool declaration content, since TypeScript is a concise language with a comprehensive type system, able to express the types and constraints of tool parameters with brief text. The code 1 shows an example for two simple tools in JSON format compatible with OpenAI’s chat completion API, as a comparison,the same tools defned in TypeScript (listed in Code 2) is much shorter. To improve compatibility, part of our trainingi data also uses JSON as the tool declaration language, so that 3rd-party frameworks need not additional development to support our tool calling scheme.
Listing 1: Tool defnition with JSON in OpenAI compatible APIi
[{
"type": "function",
"function": {
"name": "get_weather",
"description": "Getweatherfor a locationand date",
"parameters": {
"type": "object",
"properties": {
"location": {
"type": "string",
"description": "City andcountry e.g. Beijing , China"
},
"date": {
}
"type": "string",
"description": "Date to query , format in‘%Y-%m-%d’"
},
"required": [
"location"
]}}}
{
"type": "function",
"function": {
"name": "Calculator",
"description": "Simplecalculator",
"parameters": {
"properties": {
"expr": {
}
"type": "string",
"description": "Arithmeticexpression in javascript"
},}
"type": "object"
}
}]
Listing 2: Tool defnition in TypeScripti
namespacefunctions {
// Get weatherfor a locationand date
typeget_weather = (_: {
// City andcountry e.g. Beijing , China
location: string ,
// Date to query , format in‘%Y-%m-%d’
date ?: string
}) => any;
// Simplecalculator
typeCalculator = (_: {
// Arithmeticexpression in javascript
expr ?: string
}) => any;
}
en template of the tool invoking section in the model’s response messages is listed as follows
<tool_call_section_begin|>
<|tool_call_begin|>
// call_id part
functions.{{tool name}}:{{counter}}
<|tool_arguments_begin|>
{{ json serialized call arguments }}
<|tool_call_end|>
<|tool_call_begin|>
// more tool calls
<|tool_call_end|>
<|tool_call_section_end|>
As shown in the template, we support parallel tool calling by placing multiple tool calls in a single response turn. Each tool call has a unique call id, formatted as functions.{tool-name}:{counter}, where tool-name is the name of the tool, and counter is an auto-increasing counter of all tool calls starting from 0 in the dialog.
During inference, the model may occasionally generate unexpected tokens, leading to format errors when parsing a tool call. To solve this issue, we developed a constrained decoding module named enforcer, inspired by lm-format-enforcer6.When a <tool_call_section_begin|> token is generated, it ensures that the upcoming tool-related tokens follow the predefned template, and the JSON argument string follows the declared schema.i
The tool result message is simply a text message encoded with the tool’s call id and the corresponding results.
<|im_begin|>
tool
<|im_middle|>
## Results of {{call_id}}
{{ execution result content }}
<|im_end|>
CEvaluation Details
Coding Tasks.We evaluate Kimi-K2-Instruct’s capabilities on competitive coding benchmarks, LiveCodeBench and OJBench, where Kimi-K2-Instruct attains superior performance with scores of $53.7\%$ and $27.1\%,$  respectively. This excellence spans both medium-level coding challenges, such as LeetCode and AtCoder, and hard-level contests like NOI and ICPC, outperforming leading open-source and proprietary models. For multilingual programming profciency, wei employ MultiPL-E, covering languages including C++, C#, Java, JavaScript, PHP, Go, Kimi-K2-Instruct surpasses topopen-source models with an accuracy of $85.7\%,$  compared with $83.1\%$ for DeepSeek-V3-0324 and $78.2\%$  for Qwen3235B-A22B. In software engineering tasks, Kimi-K2-Instruct demonstrates robust performance on SWE-bench Verifedi(Python), SWE-lancer (Python), SWE-bench Multilingual, and Multi-SWE-bench datasets. It signifcantly outperformsi open-source counterparts in resolving real-world code repository issues and notably narrows the performance gap with proprietary models. For example:
SWE-bench Verifed (multiple attempts):i $71.6\%$ (Kimi-K2-Instruct) vs. $80.2\%$ (Claude 4 Sonnet)
SWE-bench Multilingual: $47.3\%$ (Kimi-K2-Instruct) vs. $51.0\%$ (Claude 4 Sonnet)
SWE-lancer: $39.1\%$ (Kimi-K2-Instruct) vs. $40.8\%$ (Claude 4 Sonnet)
On PaperBench, Kimi-K2-Instruct achieves an accuracy of $27.8\%,$ closely matching GPT-4.1 and outperforming DeepSeek-V3-0324 (12.2%) and Qwen3-235B-A22B $(8.2\%)$  by a substantial margin. In terminal interaction tasks measured by TerminalBench, Kimi-K2-Instruct attains $25.0\%$  using the default Terminus framework and rises to $30\%$ within Moonshot’s in-house agentic framework, underscoring its capabilities in real-world agentic programming scenarios. Moreover, on the Aider-Polyglot benchmark, Kimi-K2-Instruct attains a $60.0\%$  accuracy while employing rigorous decontamination procedures, further illustrating its strength and reliability across diverse coding environments.
Tool Use Tasks.We evaluate multi-turn tool use with two complementary suites: $\boldsymbol{\tau^{2}}$ -Bench and ACEBench. $\boldsymbol{\tau^{2}}$ Bench extends the original $7$ -bench single-control setup to a dual-control environment in which both the agent and an LLMsimulated user have constrained tool affordances over a shared state, adding a realistic Telecom troubleshooting domain alongside the prior Airline/Retail TAU tasks and enabling analysis of coordination vs. pure reasoning. ACEBench is a large bilingual (En/Zh) API-grounded benchmark (4.5K APIs across 8 domains; 2K annotated eval items) partitioned into NORMAL (basic/personalized/atomic), SPECIAL (imperfect or out-of-scope inputs), and AGENT (scenario-driven multi-turn, multi-step sandbox) tracks with automated grading of calls and outcomes. All models run in non-thinking mode; we set the temperature to 0.0, use deterministic tool adapters, score $\boldsymbol{\tau^{2}}$  Airline/Retail/Telecom under Avg@4 seeds with Pass@1/4, and report overall on ACEBench English. Kimi-K2-Instruct averages 66.1 micro Pass@1 across $\boldsymbol{\tau^{2}}$ vs DeepSeek-V3-0324 48.8 / Qwen3-235B-A22B 37.3. On ACEBench Overall Kimi-K2-Instruct scores 76.5 vs DeepSeek 72.7 / Qwen 70.5 and remains competitive with GPT-4.1 (80.1).
Math & STEM & Logical Tasks.For Math tasks, Kimi-K2-Instruct achieves consistently strong performance,averaging over Geimini-2.5-Flash by 5.3 percentage points, over DeepSeek-V3-0324 by 5.5 points and over GPT4.1 by 15.8 points. For example, on AIME 2024, Kimi-K2-Instruct scores $69.6\%,$  outperforming another two top open-source models by a large margin, DeepSeek-V3-0324 by 10.2 points and Qwen3-235B-A22B by 29.5 points. In STEM evaluations, Kimi-K2-Instruct achieves $75.1\%$ on GPQA-Diamond, outperforming DeepSeek-V3-0324 (68.4%) and all non-thinking baselines by at least 5 percentage points. On SuperGPQA, it also exceeds the previous best open-source model, DeepSeek-V3-0324, by 3.5 points. Kimi-K2-Instruct also surpasses the other two leading models in logical reasoning. It achieves $89.0\%$ on ZebraLogic and $89.5\%$  on AutoLogi, exceeding DeepSeek-V3-0324 (84.0%, 88.9%) and substantially outperforming Qwen3-235B-A22B $(37.7\%,83.3\%).$
General Tasks.Kimi-K2-Instruct ties DeepSeek-V3-0324 on MMLU and MMLU-Pro, and takes the lead on MMLURedux with a 92.7 EM score—slightly ahead of GPT-4.1 (92.4) and just 1.5 points behind Claude-Opus-4. Beyond multiple-choice tasks, the model achieves $31.0\%$  accuracy on the short-answer SimpleQA—3.3 points above DeepSeekV3-0324 and more than twice that of Qwen3-235B-A22B—though still below GPT-4.1 $(42.\tilde{3\%}).$  On the adversarial free-response LiveBench (2024-11-25 snapshot), it reaches $76.4\%,$  surpassing Claude-Sonnet 4 (74.8%) and leading Gemini 2.5 Flash Preview by 8.6 points. Across this challenging triad measuring breadth, depth, and robustness of world knowledge, Kimi-K2-Instruct secures a top-tier position among open-source models. We evaluate instruction-following with IFEval and Multi-Challenge. On IFEval, Kimi-K2-Instruct scores $89.8\%,$  higher than DeepSeek-V3-0324 (81.1%)and GPT-4.1 (88.0%). On Multi-Challenge, which involves multi-turn dialogues with conficting instructions, it achievesl 54.1%, outperforming DeepSeek-V3-0324 (31.4%), GPT-4.1 (36.4%), and Claude-Opus-4 $\left(49.0\%\right)$ . These results demonstrate that Kimi-K2-Instruct integrates strong factual knowledge with consistent instruction adherence across both single- and multi-turn settings, supporting robust and reliable real-world deployment.
Long Context and Factuality Tasks.To evaluate the factuality of Kimi-K2-Instruct, we employ three benchmarks:FACTS Grounding, which measures adherence to provided documents using the proprietary models GPT-4o, Gemini 1.5 Pro and Claude 3.5 Sonnet; HHEM, which assesses summarization quality via the open-source HHEM-2.1-Open judge; and FaithJudge, which analyzes faithfulness in RAG tasks with o3-mini as the judge. Kimi-K2-Instruct scores 88.5 on FACTS Grounding, substantially outperforming all open-source rivals and even surpassing the closed-source Gemini 2.5 Flash. With HHEM-2.1-Open it achieves a hallucination rate of 1.1 %, reported in the tables as 1 minus the

Figure 11: Chinese in-house benchmark evaluation.
rate, i.e. 98.9. On FaithJudge’s RAG tasks the hallucination rate is $7.4 \%,$ likewise present as 92.6 for table consistency.For long-context capabilities, Kimi-K2-Instruct outperforms all open source and proprietary models on DROP (93.5%),and exceeds DeepSeek-V3-0324 on retrieval task MRCR $(55.0\%$  vs $50.8\%$ . For long-context reasoning tasks FRAMES and LongBench v2, Kimi-K2-Instruct $(77.1\%,49.1\%)$  lags slightly behind DeepSeek-V3-0324 by around $2\%.$
Open-Ended EvaluationBeyond static, closed-ended benchmarks, we evaluate the model’s performance on openended, nuanced tasks that more closely resemble real-world usage.
For English scenarios, we leverage the Arena-Hard-Auto v2.0 benchmark, which use LLM-as-a-judge protocols to assess generation quality across diverse, open-ended prompts [42]. These evaluations cover a wide range of highdiffculty prompts and are widely recognized in the research community. On Arena-Hard-Auto v2.0, Kimi-K2-Instructi achieves state-of-the-art win-rate on both hard prompts $\left(54.5\%\right)$  and creative writing tasks $(85.0\%)$ , outperforming all open-source models and rivaling top proprietary systems such as GPT-4.1 and Claude Sonnet. These results underscore the model’s strength in handling complex reasoning and nuanced generation under diverse, unconstrained settings.
However, Arena-Hard-Auto provides limited coverage of Chinese-specifc tasks. To address this gap, we developedi an in-house held-out benchmark grounded in authentic user queries. To safeguard the integrity of the evaluation, the benchmark data is access-restricted, thereby eliminating the risk of overftting.i
As shown in Figure 11, Kimi-K2-Instruct shows strong performance across all comparisons on Chinese in-house benchmarks. It outperforms ChatGPT-4o-latest with a $65.4\%$  win rate, Claude Sonnet 4 with $64.6\%,$  and DeepSeek-V30324 with $59.6\%.$  In all cases, the loss rate stays low (around $17\%$ ), indicating that Kimi-K2-Instruct rarely falls behind.The high win rates and consistent margins demonstrate its strong ability on open-ended Chinese tasks.
In addition to controlled evaluations, we also consider real-world user preference through public human assessments.As of July 17, 2025, Kimi-K2-Instruct ranked as the top open-source model and ffth overall on the LMSYS Arenai leaderboard7, based on over 3,000 blind votes from real users. Unlike LLM-as-a-judge protocols, this leaderboard refects direct human preference on diverse, user-submitted prompts, providing a complementary perspective on practicall model performance.
The results on Arena-Hard-Auto, our in-house benchmark and votes from LMSYS Arena collectively offer a comprehensive view of Kimi-K2-Instruct’s open-ended capabilities, showing that it is a highly preferred model in real-world user experience across English and Chinese.
DQK-Clip Does Not Impair Model Quality
The QK-Clip design follows a minimal intervention principle: it activates only when necessary, and deactivates after training stabilizes. Empirical evidence and analysis converge on its negligible impact on model quality.

Figure 12: Applying QK-Clip to Muon in a small-scale setting with an aggresive threshold $(\tau=30)$  has negligible impact on loss, indicating that it is a safe and effective method for constraining attention logits.
Small-Scale AblationsWe train two small-scale 0.5B activated and 3B total parameters MoE models, one with vanilla Muon and the other with MuonClip using a low clipping threshold $\left(\tau=30\right)$  As shown in Figure 12, applying MuonClip has negligible effects on the loss curve, indicating that even aggressive clipping does not impair convergence or training dynamics with MuonClip. This demonstrates that MuonClip is a safe and effective method for bounding attention logits without degrading model performance. Furthermore, evaluation on downstream tasks reveals no statistically signifcanti degradation in performance. These results collectively demonstrate that MuonClip is a safe and effective method for bounding attention logits without compromising model quality.
Self-deactivationIn Kimi K2, QK-Clip was only transiently active:
• Initial 70000 steps: $12.7\%$ of attention heads triggered QK-Clip for at least once, clamping $S_{\max}$  to 100.
Post-70000 steps: All heads at some point reduced their $S_{\max}$ below 100, rendering QK-Clip inactive.
When QK-Clip is active, it is applied per-head (rather than per-layer) to minimize potential over-regularization on other heads. After training stabilizes, QK-clip is deactivated and has no effect at all.
EWhy Muon is More Prone to Logit Explosion
Logit explosion occurs when the largest pre-softmax attention score
$$S_{\max}=\max_{i,j} \left( q_{i} \cdot k_{j} \right)$$
(1)
grows unboundedly during training. Since
$$|q_{i} \cdot k_{j}|\leq\|q_{i}\|\|k_{j}\|\leq\|x_{i}\|\|x_{j}\|\|\mathbf{W}_{q}\|\|\mathbf{W}_{k}\|,$$
(2)
and RMS-Norm keeps $\| x_{i} \|\| x_{j} \|$ bounded, the phenomenon is primarily driven by the growing spectral-norm of $\mathbf{W}_{q}$ or $\mathbf{W}_{k}$  Empirically, we found that Muon is more susceptible to logit explosion. We give our hypothesis below.
Structural difference in updatesMuon produces a weight update coming from the msign operation; as a result, $all$ singular values of the update matrix are equal — its effective rank is full. In contrast, a typical update matrix produced by Adam exhibits a skewed spectrum: a few large singular values dominate, and the effective rank is low. This low-rank assumption for Adam is not new; higher-order muP makes the same assumption.
Such phenomenon is verifed on the 16 B Moonlight model, which shows weights trained with Muon exhibit higheri singular-value entropy (i.e. higher effective rank) than those trained with Adam, corroborating the theoretical intuition.
SVD formulationLet the parameter matrix at step $\boldsymbol{t}-1$  have the singular value decomposition
$$\mathbf{W}_{t-1}=\sum_{i}\sigma_{i} u_{i}v_{i}^{\top}$$
(3)

We write the update matrices as
$$\Delta\mathbf{W}_{t}=\sum_{j}\bar{\sigma} \bar{u}_{j}\bar{v}_{j}^{\top}$$
(4)
The next parameter update is therefore
$$\mathbf{W}_{t}\leftrightarrow\sum_{i}\sigma_{i}u_{i}v_{i}^{\top}+\sum_{j}\bar{\sigma} \bar{u}_{j}\bar{v}_{j}^{\top}$$
(5)
In Muon, as both the weights and the updates have a higher effective rank than Adam, we hypothesize there is a higher probability for singular-vector pair $u_{i}v_{i}^{\top}$ to align with $\bar{\bar{u}}_{j}\bar{v}_{j}^{\top}.$  This could cause the corresponding singular value of $\mathbf{W}_{t}$ to increase additively.
Attention-specifc amplifcationAttention logits are computed via the bilinear formii
$$q_{i}\cdot k_{j}=(x_{i}\mathbf{W}_{q})\cdot(x_{j}\mathbf{W}_{k}).$$
(6)
The product $\mathbf{W}_{q}\mathbf{W}_{k}^{\top}$ squares the spectral norm, so any singular-value increase in either matrix is compounded. Muon’s tendency to enlarge singular values therefore translates into a higher risk of logit explosion.
FK2 Critic Rubrics for General RL
F.1Core Rubrics
Clarity and Relevance: Assesses the extent to which the response is succinct while fully addressing the user’s intent. The focus is on eliminating unnecessary detail, staying aligned with the central query, and using effcienti formats such as brief paragraphs or compact lists. Unless specifcally required, long itemizations should be avoided.i When a choice is expected, the response should clearly offer a single, well-defned answer.i
Conversational Fluency and Engagement: Evaluates the response’s contribution to a natural, fowing dialogue thatl extends beyond simple question-answering. This includes maintaining coherence, showing appropriate engagement with the topic, offering relevant observations or insights, potentially guiding the conversation constructively when appropriate, using follow-up questions judiciously, handling hypothetical or personal-analogy queries gracefully,and adapting tone effectively to suit the conversational context (e.g., empathetic, formal, casual).
Objective and Grounded Interaction: Assesses the response’s ability to maintain an objective and grounded tone, focusing squarely on the substance of the user’s request. It evaluates the avoidance of both metacommentary(analyzing the query’s structure, topic combination, perceived oddity, or the nature of the interaction itself) and unwarranted fattery or excessive praise directed at the user or their input. Excellent responses interact respectfullyl but neutrally, prioritizing direct, task-focused assistance over commentary on the conversational dynamics or attempts to curry favor through compliments.
F.2Prescriptive Rubrics
Initial Praise: Responses must not begin with compliments directed at the user or the question (e.g., “That’s a beautiful question”, “Good question!”).
Explicit Justifcation: Any sentence or clause that explains why the response is good or how it successfullyi fulflled the user’s request. This is different from simply describing the content.i
F.3Limitations
One potential side effect of this evaluation framework is that it may favor responses that appear confdent and assertive,i even in contexts involving ambiguity or subjectivity. This stems from two key constraints in the current rubric:
Avoidance of Self-Qualifcation: The prescriptive rules prohibit self-assessments, explicit disclaimers, or hedgingi language (e.g., “this may not be accurate”, “I might be wrong”). While these phrases can refect epistemic humility,l they are often penalized as non-informative or performative.
Preference for Clarity and Singularity: The rubric reward direct, decisive answers when users ask for a recommendation or explanation. In complex or open-ended scenarios, this may disincentivize appropriately cautious or multi-perspective responses.

As a result, the model may occasionally overstate certainty in areas where ambiguity, nuance, or epistemic modesty would be more appropriate. Future iterations of the framework may incorporate more fne-grained handling of calibratedi uncertainty.

GEngine Switching Pipeline for RL Training
Figure 13: pipeline for RL weight update
The checkpoint engine manages three equal-size device buffers on each GPU: an H2D buffer for loading the offoadedl model parameters, and two IPC buffers for GPU-to-GPU broadcast. The IPC buffers are shared to inference engines,allowing it to directly access the same physical memory. These three buffers allow us to arrange the three steps in a pipeline.
Theoretical three-stage pipeline.As illustrated in Figure 13a, a three-stage pipeline is introduced. (1) $\mathit{H2D:}$  a shard of the latest weights is copied into the H2D buffer asynchronously. (2) Broadcast: Once the copy completes, the shard will be copied to one IPC buffers and broadcast to all devices. (3) Reload: Inference engines simultaneously load parameters from the other IPC buffer.
Two-stage pipeline due to PCIe saturation.On NVIDIA H800 clusters, concurrent H2D and broadcast saturate the shared PCIe fabric, collapsing the three stages into a sequential procedure (Figure 13b). We therefore adopt a simpler,two-stage scheme (Figure 13c): (1) All devices perform a single, synchronous H2D transfer. (2) The broadcast and reload proceed in parallel.
The two-stage pipeline will be bound by multiple synchronous H2D copy operations. But in large scale devices, model will be split into small shards, the entire parameter set fts into the H2D buffer in one transfer, the overhead willi disappear.
By overlapping H2D, Broadcast, and Reload weights, we can obtain a high bandwidth to reshard the weights from train engines to all inference engines.
